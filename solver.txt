// Sources flattened with hardhat v2.12.2 https://hardhat.org

// File contracts/Nft_3_20Verifier.sol

// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 7085602068770398920309556536306556584743415111650492076418145582318111212938;
    uint256 constant deltax2 = 14326749425507221642992194535494486175288787953650901718878031198972435321296;
    uint256 constant deltay1 = 13879818066674376527840961917826137470757910181935355838812335711779501518085;
    uint256 constant deltay2 = 4042185603919029000556976554221528464243139509851081871391295406225072140917;

    
    uint256 constant IC0x = 14494753926915411832159529689114552409781681201675666995795674570741701103594;
    uint256 constant IC0y = 15007006774672634858441419753877257322229362490634014051482798637632333126386;
    
    uint256 constant IC1x = 1530346015323589456098505316751051999204918273305423318034586833210095417927;
    uint256 constant IC1y = 9701628878183265555347213064739530248824488252198205372197837211699632007163;
    
    uint256 constant IC2x = 7360616143414052187432649436516116728724483551269906632356436713490638252056;
    uint256 constant IC2y = 6817765074180274067086291614492728533202007024581048653762638428872026970675;
    
    uint256 constant IC3x = 16698138739974020731222148255511070005433445358916286223041970623269721715034;
    uint256 constant IC3y = 20071417856411792617321307361986344876533359294148839177119595941051308469984;
    
    uint256 constant IC4x = 19012494379250570972218748998511724508591185376460792166750480771903698030492;
    uint256 constant IC4y = 15450916702474508938863256028317402442972820959834998488177583632450196467406;
    
    uint256 constant IC5x = 16851411485750553026006423583609567656657142140340074040107050475839145349369;
    uint256 constant IC5y = 14470994314404331870122151393881430131892395324151605116173916088749931980814;
    
    uint256 constant IC6x = 5961047615060412023040658013539061365166288103066153602068803744338773532653;
    uint256 constant IC6y = 14420036930283269972930704430103144962041691140447261398388471787587972689797;
    
    uint256 constant IC7x = 16159841065978726110313962740868013841701112644071038922310505485264291466085;
    uint256 constant IC7y = 7234899327276175040336539980044134370013751290628915645734638156921750652593;
    
    uint256 constant IC8x = 1189575717391044552222166063457441597794137029452846648618033427006083617323;
    uint256 constant IC8y = 1795183036224392919363186555210269304743372081117350141993986864825266491083;
    
    uint256 constant IC9x = 5977483287171232254272230131476314119384234684044289736813685150793592981708;
    uint256 constant IC9y = 3630230568199283895994297825204352396826869929731310648399089198681651580223;
    
    uint256 constant IC10x = 833169986625734629630994046316864338658185459982392961119841585382184327627;
    uint256 constant IC10y = 5405853463044117490975602370299296794079988676566126551001728087452657474410;
    
    uint256 constant IC11x = 8294636124202778362099448763550602323016565282777034242854773714797899818099;
    uint256 constant IC11y = 18657046700246226836508995232962987303049963656638575327864129798076083400939;
    
    uint256 constant IC12x = 15019578918080718272784013075039436979365825204132541978442963806683573798871;
    uint256 constant IC12y = 5316471495709781771693296989915232966436001194789580362520969063673992778918;
    
    uint256 constant IC13x = 2184021111955591447395815626498256896528649022871844947975718919730537706165;
    uint256 constant IC13y = 12791460177693917699819254987552489611385785346837214061397557604230657113609;
    
    uint256 constant IC14x = 5806422665687711265371153616700325729880999325309445320164996939334996497050;
    uint256 constant IC14y = 853301837142096886518056362598128005542239756145319369415652843278077887194;
    
    uint256 constant IC15x = 15605809144765403053112458011238314620833285560656349752224741497388520429014;
    uint256 constant IC15y = 688483144707994122667793817550737845227046352754168292148403815457941612445;
    
    uint256 constant IC16x = 19659263907473979504166838409504373312741599432366631100591706306467975500645;
    uint256 constant IC16y = 13069164054698690849194599723774323734733928362738000645678315052956747034792;
    
    uint256 constant IC17x = 1101012515991641610362447614872665905996086855545553603087720844601315549235;
    uint256 constant IC17y = 570680223702471337967175633739655193366870222701012117703742114720159417674;
    
    uint256 constant IC18x = 17341272514642391662852707566043128151319133512416556434788315470568384985404;
    uint256 constant IC18y = 16651749502290712550160425606886342566678936295936965970864689070981519384943;
    
    uint256 constant IC19x = 17577663962696247215486147932750241748885513129212427733745454146070493238133;
    uint256 constant IC19y = 2580980493730293209872330650428825193058554278380312592983342219882144780749;
    
    uint256 constant IC20x = 14945028217194982237101379959401354851805251687735662332738546360732388313882;
    uint256 constant IC20y = 4292860661593505967379029720835393158716420044116364746191050675453415012997;
    
    uint256 constant IC21x = 12707464406269295842232955006771142921994054594939409919638844493044852787491;
    uint256 constant IC21y = 20306366152030313233884668286081545074717818171086390980221225103191942847300;
    
    uint256 constant IC22x = 6213552055948168756529847015171172207407781712490434054639175349956066614136;
    uint256 constant IC22y = 8592842830143251500569184970105491433286144276663267414119444135964407191927;
    
    uint256 constant IC23x = 11519996074966180666762248168652950620574144435535862397670747174861901328767;
    uint256 constant IC23y = 14590032459415501051987998798671165846543971315309202832688173874872146764206;
    
    uint256 constant IC24x = 3629029177094115563415890973809879534364540564956343913064322694416668049020;
    uint256 constant IC24y = 3022880353641118692480003250536162029568873734019455445132834537371015333102;
    
    uint256 constant IC25x = 2960479443987149553731228191620519848773886402274229821082266686920861153318;
    uint256 constant IC25y = 10849757330470467406657126098912966074659814710377122761252746160962315715529;
    
    uint256 constant IC26x = 13325728179309160523283867208085101559923387679974897513364042071790904630683;
    uint256 constant IC26y = 14218063806827536461653238876877051864815142740578362244195665805624615755527;
    
    uint256 constant IC27x = 7904926387175743619178490703680397374161454882027991933834992863948852406687;
    uint256 constant IC27y = 11589123114661153063808137390269118468143340192649534937400178959070217988813;
    
    uint256 constant IC28x = 6500999613652960731420578674233723858652115242197465388435888233919080208828;
    uint256 constant IC28y = 4635657659672984823712205565456140387041324623495963288099362163560133278684;
    
    uint256 constant IC29x = 21595677676449104045567216084991927326129357480181072458522636774124632493154;
    uint256 constant IC29y = 8805507806318965964290511926716037566348681709668391663327198681174004311007;
    
    uint256 constant IC30x = 16965220905498552198653537826631602801018412693825744731631381459848913158747;
    uint256 constant IC30y = 15980922521758803278099432993830081197610486446920540061339818564816984632041;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[30] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }


// File contracts/Nft_6_20Verifier.sol

// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 10602636189284862942531069995320709848070782616110225744762242778239897671839;
    uint256 constant deltax2 = 18624343660236480011607670803179042090706275621843592614950634333381843290265;
    uint256 constant deltay1 = 177791425570114457289642777472203244098448978331745870421296835456600865937;
    uint256 constant deltay2 = 6926219160851706573866369028613308564135476163889361267540447765081729515716;

    
    uint256 constant IC0x = 21766654085119707257739087100197523787472789441112177937590430387564944348796;
    uint256 constant IC0y = 6303864600472398368667073157387768574998375540927162511459788978369127415100;
    
    uint256 constant IC1x = 12488912265065383934304951135773539043170361588306301481966955328357005837872;
    uint256 constant IC1y = 14786784146231210287133114174398964709926960078248362102125629187022521307519;
    
    uint256 constant IC2x = 10440488567157742209574001613696518857445045832140392452075591157899271808136;
    uint256 constant IC2y = 21156213539561527851483811667175497870047012763823026184777638704377410566565;
    
    uint256 constant IC3x = 11686984370425353154316406867971935237840929811487825287902291021176245811202;
    uint256 constant IC3y = 7294674891072705332643926086601956788073841726260124220478681725071181131754;
    
    uint256 constant IC4x = 7795414795748571700883537494015881837439207427327926800436749618041705168587;
    uint256 constant IC4y = 16691221892477472709124284435534467153752030087250613723293946979683481189804;
    
    uint256 constant IC5x = 16798921719715669301977156581078187934621114523300724714834373669671901981927;
    uint256 constant IC5y = 8918912732458115344461696358841029117529914802979324623637284002135865921204;
    
    uint256 constant IC6x = 11189627417168251966494320383882066840140189872588452160155522951518293331345;
    uint256 constant IC6y = 3608308292695627186135431598334467072318978083586282889511658336092648218568;
    
    uint256 constant IC7x = 6251304325476041732744153903335681416932629382420513671755656544648760128665;
    uint256 constant IC7y = 3604893520311951052041640440397942487964666837714527929913424905726826562;
    
    uint256 constant IC8x = 731725068000390155438253927865759966764662422266182305915579870400604244989;
    uint256 constant IC8y = 604237191554042171079020751163053822123207905899393582762744241094686620004;
    
    uint256 constant IC9x = 6608067462706717786075283278683015355841986473726446855476109319904649978385;
    uint256 constant IC9y = 13108421541115166743733671238514402779696106244498054927150602777350106165534;
    
    uint256 constant IC10x = 8239888069399855192096034079065111993418464020223956434214174574158774851677;
    uint256 constant IC10y = 7127742595795797813043994254501760992876776770637381479850813130848178764878;
    
    uint256 constant IC11x = 20366880726699328966512920787913640957889336785803496015065905999975310125921;
    uint256 constant IC11y = 327516963132598624810668702087948579013437403001960594800415264994098931086;
    
    uint256 constant IC12x = 14676993507037201325445879473349937362221439072733632122789262231672496844939;
    uint256 constant IC12y = 12953507458525740423651370538561250429668096498166576201960948123717069110332;
    
    uint256 constant IC13x = 2493590630713165131721889563610684090400670033894640246101290320584315930092;
    uint256 constant IC13y = 14058032784667254708198964920333335643929145974100233555711859601164810103029;
    
    uint256 constant IC14x = 7525810505214990596944105029528583210480448249756350320743722272091753009960;
    uint256 constant IC14y = 7528483465878891887601290791226721740558376104427678100022616186016943177956;
    
    uint256 constant IC15x = 18697406807884540111619185705697481019017421887144393199969624698406089096081;
    uint256 constant IC15y = 11771133421647546133200051423066073917507694227322832506381219777678317261984;
    
    uint256 constant IC16x = 735713601114084519041580602658022748668718677402722883727601162411991038830;
    uint256 constant IC16y = 5978179238291348147656986119693542117372387627778682617150448658888630996483;
    
    uint256 constant IC17x = 6896664672398336048787286098271098892044768506580689953447277260764349888979;
    uint256 constant IC17y = 9490022275307378061447498647684787179901332780640634317628068753708134636046;
    
    uint256 constant IC18x = 17795120568310524188089865261629394343642375856969387717824785719294438791326;
    uint256 constant IC18y = 1624756729523650263763633219049953454922206760290088190025316606998899898842;
    
    uint256 constant IC19x = 15443546977756285935852031497458302927494717436044826463731551179066888909950;
    uint256 constant IC19y = 3717627820089685175934019328393516703617410581102651202472763134818828504862;
    
    uint256 constant IC20x = 1520218195627671480126214521901932222846171336791955981206465976608900477268;
    uint256 constant IC20y = 11274386974946917651542739179187671312336023845688660840284908169611415744012;
    
    uint256 constant IC21x = 18232657174082558572002816464319232582644166002499211264060114184379955295378;
    uint256 constant IC21y = 8034747988014079060354275915835453479013811412285605303247876546503683526461;
    
    uint256 constant IC22x = 752881260446781178148621360750773468232215275235711206280054080856152468279;
    uint256 constant IC22y = 19852310224735672610832726904114630031872354977169601265438119554370878777948;
    
    uint256 constant IC23x = 8648570537019508507176111570215947649093269622735211070023740960688333178381;
    uint256 constant IC23y = 1826664388253362057460721273273103552864511591907918060356771488054896488942;
    
    uint256 constant IC24x = 6927544872577401906265790615926684802531734292178523237305515018385679134929;
    uint256 constant IC24y = 13488970973264336819789254144400640084304559286947462744095859331117738736935;
    
    uint256 constant IC25x = 12621691006978088690537754132909557707296488996982777138983725308199696549927;
    uint256 constant IC25y = 2683541088479569453356379716345327174301228302422073121503278206734051024240;
    
    uint256 constant IC26x = 3825308915671168378795379945595504070516292570367634140813913002907318025765;
    uint256 constant IC26y = 8709741457073687657201824165090773161575615209981556575741981510291510533948;
    
    uint256 constant IC27x = 19094410259332101944183275626632779266101914827898352734511798047153239929353;
    uint256 constant IC27y = 6831126810262455720888895293869610818397828125766458593406626018737634114357;
    
    uint256 constant IC28x = 20874103943866525457507581688629124372291578869847504192953626567020049834923;
    uint256 constant IC28y = 21049105037916933016146713625866990050459260024459537966949413414186118679776;
    
    uint256 constant IC29x = 17082900094386885934890408043188446984022401621241458669557075836997587380150;
    uint256 constant IC29y = 18306865874888916432583138775134836755125331831238195428656083350417724129429;
    
    uint256 constant IC30x = 6211215671761599749090295023391203563845642842832737614984089727737951246801;
    uint256 constant IC30y = 3282649178667605998099712764137965675865736317075428671846328632732808688840;
    
    uint256 constant IC31x = 5086184627445772290861300755667297085585718802376940135485114498037606031258;
    uint256 constant IC31y = 1488530025417521084674611520140004711620055827625798758801004419886020861566;
    
    uint256 constant IC32x = 2057723945911245042316414683044241583002194011421118018408931426544785371675;
    uint256 constant IC32y = 16164004632436145688880263813831985318505311858893836699999142013566010254493;
    
    uint256 constant IC33x = 11757990279303900986792532355270668855761126694316124776461518599504763556269;
    uint256 constant IC33y = 8811740412349894817379145877398516591484104237016197830204820104328525843445;
    
    uint256 constant IC34x = 20068237329629349199496669050139935504591677440689249561956430044978481320346;
    uint256 constant IC34y = 20631937968156728277206117189905762080460623475669510018177673897984827555283;
    
    uint256 constant IC35x = 15078910647922981637507006130683848335884663754415299443020116279283707926446;
    uint256 constant IC35y = 17970253989402936870879695550402361702539313205516446624575424542385782812832;
    
    uint256 constant IC36x = 3672900654031275856041126406616255334921303825935627521213301053700137241470;
    uint256 constant IC36y = 3849534249766998177863122211644256449932268120709059041136350957674168170724;
    
    uint256 constant IC37x = 15043504625455654664590893251494859111064302846164585018061352000413966276901;
    uint256 constant IC37y = 4896677877942507325651953949972282320070280956644371801157645694942650919366;
    
    uint256 constant IC38x = 16609691707981979187780463724549424830035320298654304257077143283988362089006;
    uint256 constant IC38y = 19320290610235981015467367705683180348936547347183110156081752647923236837774;
    
    uint256 constant IC39x = 9223664165335461328514206557304744867996186584072711101964246094389936768277;
    uint256 constant IC39y = 13224784430175223003929018670655033149147472607431910627316173447102770512106;
    
    uint256 constant IC40x = 11032270435626976062566353980551219572980894852859762309645446665671443825038;
    uint256 constant IC40y = 9338894159017903995117247640564790865046888797407609456388996912164649091394;
    
    uint256 constant IC41x = 7374578448065485328467666835691524651506261115278795436167443563113995776040;
    uint256 constant IC41y = 10892078076179188646645022466127839821466863776435825789551631544990611584656;
    
    uint256 constant IC42x = 20562946450307223356919685154055083730200094867355545117537941956012722133176;
    uint256 constant IC42y = 14788245952783632352573752245871646489257611273748032702489779877344724655883;
    
    uint256 constant IC43x = 17121952439331450734349790617309809589596834679120500594802365970265389668199;
    uint256 constant IC43y = 12323565157164164810641806575760641943114568583673142729960481733524903585067;
    
    uint256 constant IC44x = 20435513906044137220508510879790684316689694229947053471548195181570984289170;
    uint256 constant IC44y = 11048182063620986075015569902422687652539956011168793468940129961101357770653;
    
    uint256 constant IC45x = 4349535718145621183312689867644766391284824667482099341185499474353228476200;
    uint256 constant IC45y = 17773407450784961148504035279921054437443870034279476271439704621092644942517;
    
    uint256 constant IC46x = 3846943507613381146543666193130567475203874704021585619888990450641688811374;
    uint256 constant IC46y = 18544805564120049050718721344302529397828063314073729110215391193367798531997;
    
    uint256 constant IC47x = 9899735852313629001302550123404655429644502658444654758341487316841722858045;
    uint256 constant IC47y = 15033050832894846616264129822790237916815262667921819885531970173159873084835;
    
    uint256 constant IC48x = 5995507937803571592809271989081042150992951010632854644881899694201434111515;
    uint256 constant IC48y = 3017273591137293076209233298830176174169245325096866867881550599869396676199;
    
    uint256 constant IC49x = 13811463589571186792965613057051864899547137448144288247924785693022286203283;
    uint256 constant IC49y = 7768978282036961981984297534336587997193684552827117817231048508735444686524;
    
    uint256 constant IC50x = 12206013345712665517827399279688014773757610217789107343264665547798012903000;
    uint256 constant IC50y = 20634926768810082311162375903111849651312450825586040372370333567605199831460;
    
    uint256 constant IC51x = 16308146891521848014878388984656654755585565859822937154648606896782419665354;
    uint256 constant IC51y = 187561526207115412866982275535662094361534550275411100929737479919446284484;
    
    uint256 constant IC52x = 12683053643097841316092523497844475676897964883332000896162890233854061097537;
    uint256 constant IC52y = 10814527006111133911596027919656971272507333320116124990465755817453935304653;
    
    uint256 constant IC53x = 12526831656715866041245144803071063538950836684364961530911330271713812018572;
    uint256 constant IC53y = 20982757047386774555106957500998321671129022664755987044617712644672417821535;
    
    uint256 constant IC54x = 16351787716287528640961965056032352535042461621386824193859447668710940330131;
    uint256 constant IC54y = 2341571575443023638628150616366946897826462249301149215450441982773713880451;
    
    uint256 constant IC55x = 2100646505811931537492455904687603555499298556194583304351096219116059690328;
    uint256 constant IC55y = 6632886227798911080301724429987774574399938286977917478064536569709941753476;
    
    uint256 constant IC56x = 6145003016676433472760144051389063895365306988587458301988779687856887657495;
    uint256 constant IC56y = 12871295220418690421044120900209058326280960975540647129634806858558530627235;
    
    uint256 constant IC57x = 17086861400162628483012920944183016537390892237637178156485267507032854295566;
    uint256 constant IC57y = 10706332967960524466016168223198395924205138766163373223361832356700577713759;
    
    uint256 constant IC58x = 10895117256437716250841061234191001868780165817093461978134973934282376658453;
    uint256 constant IC58y = 19479316597132871915453870387633028923562326192517280326102761301406521981861;
    
    uint256 constant IC59x = 3320416515255595013311586673065232426814723170268106935475755866969871244072;
    uint256 constant IC59y = 118929626332098453882706542615127549514125716688234294067878884247210548971;
    
    uint256 constant IC60x = 17225699369258283137104647422731224443501394097661645062078752629453892247466;
    uint256 constant IC60y = 6375043696331609458609140223152490580095233558087186988515022942379908723978;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[60] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                
                g1_mulAccC(_pVk, IC33x, IC33y, calldataload(add(pubSignals, 1024)))
                
                g1_mulAccC(_pVk, IC34x, IC34y, calldataload(add(pubSignals, 1056)))
                
                g1_mulAccC(_pVk, IC35x, IC35y, calldataload(add(pubSignals, 1088)))
                
                g1_mulAccC(_pVk, IC36x, IC36y, calldataload(add(pubSignals, 1120)))
                
                g1_mulAccC(_pVk, IC37x, IC37y, calldataload(add(pubSignals, 1152)))
                
                g1_mulAccC(_pVk, IC38x, IC38y, calldataload(add(pubSignals, 1184)))
                
                g1_mulAccC(_pVk, IC39x, IC39y, calldataload(add(pubSignals, 1216)))
                
                g1_mulAccC(_pVk, IC40x, IC40y, calldataload(add(pubSignals, 1248)))
                
                g1_mulAccC(_pVk, IC41x, IC41y, calldataload(add(pubSignals, 1280)))
                
                g1_mulAccC(_pVk, IC42x, IC42y, calldataload(add(pubSignals, 1312)))
                
                g1_mulAccC(_pVk, IC43x, IC43y, calldataload(add(pubSignals, 1344)))
                
                g1_mulAccC(_pVk, IC44x, IC44y, calldataload(add(pubSignals, 1376)))
                
                g1_mulAccC(_pVk, IC45x, IC45y, calldataload(add(pubSignals, 1408)))
                
                g1_mulAccC(_pVk, IC46x, IC46y, calldataload(add(pubSignals, 1440)))
                
                g1_mulAccC(_pVk, IC47x, IC47y, calldataload(add(pubSignals, 1472)))
                
                g1_mulAccC(_pVk, IC48x, IC48y, calldataload(add(pubSignals, 1504)))
                
                g1_mulAccC(_pVk, IC49x, IC49y, calldataload(add(pubSignals, 1536)))
                
                g1_mulAccC(_pVk, IC50x, IC50y, calldataload(add(pubSignals, 1568)))
                
                g1_mulAccC(_pVk, IC51x, IC51y, calldataload(add(pubSignals, 1600)))
                
                g1_mulAccC(_pVk, IC52x, IC52y, calldataload(add(pubSignals, 1632)))
                
                g1_mulAccC(_pVk, IC53x, IC53y, calldataload(add(pubSignals, 1664)))
                
                g1_mulAccC(_pVk, IC54x, IC54y, calldataload(add(pubSignals, 1696)))
                
                g1_mulAccC(_pVk, IC55x, IC55y, calldataload(add(pubSignals, 1728)))
                
                g1_mulAccC(_pVk, IC56x, IC56y, calldataload(add(pubSignals, 1760)))
                
                g1_mulAccC(_pVk, IC57x, IC57y, calldataload(add(pubSignals, 1792)))
                
                g1_mulAccC(_pVk, IC58x, IC58y, calldataload(add(pubSignals, 1824)))
                
                g1_mulAccC(_pVk, IC59x, IC59y, calldataload(add(pubSignals, 1856)))
                
                g1_mulAccC(_pVk, IC60x, IC60y, calldataload(add(pubSignals, 1888)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            
            checkField(calldataload(add(_pubSignals, 1024)))
            
            checkField(calldataload(add(_pubSignals, 1056)))
            
            checkField(calldataload(add(_pubSignals, 1088)))
            
            checkField(calldataload(add(_pubSignals, 1120)))
            
            checkField(calldataload(add(_pubSignals, 1152)))
            
            checkField(calldataload(add(_pubSignals, 1184)))
            
            checkField(calldataload(add(_pubSignals, 1216)))
            
            checkField(calldataload(add(_pubSignals, 1248)))
            
            checkField(calldataload(add(_pubSignals, 1280)))
            
            checkField(calldataload(add(_pubSignals, 1312)))
            
            checkField(calldataload(add(_pubSignals, 1344)))
            
            checkField(calldataload(add(_pubSignals, 1376)))
            
            checkField(calldataload(add(_pubSignals, 1408)))
            
            checkField(calldataload(add(_pubSignals, 1440)))
            
            checkField(calldataload(add(_pubSignals, 1472)))
            
            checkField(calldataload(add(_pubSignals, 1504)))
            
            checkField(calldataload(add(_pubSignals, 1536)))
            
            checkField(calldataload(add(_pubSignals, 1568)))
            
            checkField(calldataload(add(_pubSignals, 1600)))
            
            checkField(calldataload(add(_pubSignals, 1632)))
            
            checkField(calldataload(add(_pubSignals, 1664)))
            
            checkField(calldataload(add(_pubSignals, 1696)))
            
            checkField(calldataload(add(_pubSignals, 1728)))
            
            checkField(calldataload(add(_pubSignals, 1760)))
            
            checkField(calldataload(add(_pubSignals, 1792)))
            
            checkField(calldataload(add(_pubSignals, 1824)))
            
            checkField(calldataload(add(_pubSignals, 1856)))
            
            checkField(calldataload(add(_pubSignals, 1888)))
            
            checkField(calldataload(add(_pubSignals, 1920)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }


// File contracts/Nft_5_20Verifier.sol

// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 19582604328596298088694337929723228215064999582424736433761118822168567758182;
    uint256 constant deltax2 = 12546854585941025749470720179660647385902188416957923133912882369439214646743;
    uint256 constant deltay1 = 18444600468642474188218818268034452542394903970167736287117133704295407163714;
    uint256 constant deltay2 = 3942152978595566332631541948983966028333444526071416757234193975303084321691;

    
    uint256 constant IC0x = 10405430227285915159870911496396808565296219042798879294382250076577415900329;
    uint256 constant IC0y = 7903074469724241367725076045819963734466257448815197024561336787574095429501;
    
    uint256 constant IC1x = 566748684526888166888469102450436213536491237404959930907710618408098328125;
    uint256 constant IC1y = 17713616652454524683491046261771825862612043592892744438655681644774106444701;
    
    uint256 constant IC2x = 14315005514378711549980523045319591484948332710439045895848729044634872633269;
    uint256 constant IC2y = 526196369781431463956392263833356822257114366490075339156432057989369331125;
    
    uint256 constant IC3x = 8849877885325779530231767523027014667352331339325221299148555975919282286126;
    uint256 constant IC3y = 612571147015512299139500456720964851998104178098475865276838507781839030047;
    
    uint256 constant IC4x = 4248856652245661171593245011227770339368798432406658774557642333063602128680;
    uint256 constant IC4y = 19134384956907514137537291351620194533383729037596146557074750256980753856228;
    
    uint256 constant IC5x = 18547591900853718615048470247027469414144810191537139745056274797018149480236;
    uint256 constant IC5y = 10500061441702287542460645678003084473193455537824642792374673507515073827642;
    
    uint256 constant IC6x = 1571318485062637104607740049843439274674922801582605798760741074339683556725;
    uint256 constant IC6y = 10126192989118116721687875080180939107775384260943137766885892107914994631360;
    
    uint256 constant IC7x = 8675436107058293663543538210033120801955022298227184319256508225033138365378;
    uint256 constant IC7y = 15249757227685510865523759821211694266259228375653647196517947593805928664534;
    
    uint256 constant IC8x = 21204270175543989534212625275803064738827623669543905884274024462992885625346;
    uint256 constant IC8y = 1360871121087041947179857899996079614324324977115320327520146694145725179701;
    
    uint256 constant IC9x = 14765853280786149950956028839060589897418611970111479960951999837716235569858;
    uint256 constant IC9y = 14867427670281513271618124289291237964757785604709195492004540180147588056736;
    
    uint256 constant IC10x = 11247725700774373703685704084339624684410755045234224354699612970722875737038;
    uint256 constant IC10y = 10286190131010075089149078483108065249018497453560693883744920072408892134424;
    
    uint256 constant IC11x = 13656251545536290934481562723810861195150210151903462162647831741185506954516;
    uint256 constant IC11y = 831046786161801604822782726225583257777983357510691436993403833598401501764;
    
    uint256 constant IC12x = 21456950494028507611257012287574118551882533341687564784977891175445805686109;
    uint256 constant IC12y = 17424697886627362985187712894655776598240578279999237456071075051318530820913;
    
    uint256 constant IC13x = 16370539522420622277489406266989446616633820333367082678737668184922098197850;
    uint256 constant IC13y = 9284558236423261387622351228885419152785830156012310973541902750624547267216;
    
    uint256 constant IC14x = 13277086836820485983167355737169926579137821550329640853151667857667388335272;
    uint256 constant IC14y = 7326234713240141231079191757848216005086270994436289382141557856783467818810;
    
    uint256 constant IC15x = 17993488872591604207664073487075127224610864418525338581353908423677863578823;
    uint256 constant IC15y = 8158312449353563394238942946184138447686346824188095414839058838221000662111;
    
    uint256 constant IC16x = 653666886987411817624918748523153133063000364501713156696439187095328194058;
    uint256 constant IC16y = 11826807258559515262305067127802885853234658502398100481698886531185138360030;
    
    uint256 constant IC17x = 579465571982650262373215428108011233660396851135612619669353925807367913318;
    uint256 constant IC17y = 2405780375461889719308959052201012074602595730710440064076880457812788582663;
    
    uint256 constant IC18x = 5863000756617228891928115564048670363962706964603772308133441138680605268015;
    uint256 constant IC18y = 13145442899178665725895735773788163420569036515304802103215472608241817619853;
    
    uint256 constant IC19x = 7892276643354384346121317270051322846355297737691071746260592489216934749352;
    uint256 constant IC19y = 17407712629248883757585432627493785207537272088866181353642389479284048949761;
    
    uint256 constant IC20x = 1726825730613519564034116246498153675264912621900850610372051282894168821702;
    uint256 constant IC20y = 14653317141494400178877300596475348564341580559840114001205642807260997608089;
    
    uint256 constant IC21x = 8728595567516238884162859152648783294584519838405681176240737867274648601200;
    uint256 constant IC21y = 1929926022932853472691682262786569242697501099806468682069530385373444689136;
    
    uint256 constant IC22x = 16569794732795921914044369455863392607993006195078150965962859095521081117859;
    uint256 constant IC22y = 11269603413072482250581593833347288073178064568134539050903072866434953885845;
    
    uint256 constant IC23x = 12087710641737917741110626071291682793437717453372265290155235781619467900322;
    uint256 constant IC23y = 12418564164620752465453189157792245581170839566106668382270281573867241296467;
    
    uint256 constant IC24x = 20169322010169965808603666938194353456501065433331406674603173834718475892440;
    uint256 constant IC24y = 8102295407369791318101333582105696046964137020625620995838690785257201625289;
    
    uint256 constant IC25x = 12720226101119384906612991912725512311042086153811145983990579059789497351366;
    uint256 constant IC25y = 8652069039408706650407712062053190945366532840340614490380292699600656232076;
    
    uint256 constant IC26x = 164171303676240767037484687972097297218409783328842409106032259903890286777;
    uint256 constant IC26y = 17044345017312985461839641586216427424626938202022226197569063103753498761139;
    
    uint256 constant IC27x = 9695823835138159380571180674164036989106399811924033834148947661134162091725;
    uint256 constant IC27y = 16334193516404627313913880057242422621361988302743474751486621799094241478894;
    
    uint256 constant IC28x = 14796840694870271828001756966000737845522028478644949721831941789675020336703;
    uint256 constant IC28y = 14336423243846880711486994013235327837284055026630798756112077919799642451596;
    
    uint256 constant IC29x = 17223406173257196769759106593722235521642070592926734452481098828764391856367;
    uint256 constant IC29y = 20468374980723118461873268379841493147770818721647023389323778769433922543295;
    
    uint256 constant IC30x = 6373437618777367527888344783418312173446524656460661765390013510531213646232;
    uint256 constant IC30y = 4022288047843686314489433818811556309419353945780855408468879862557280606587;
    
    uint256 constant IC31x = 20406498838329047394051324128214595168095913637143582302918045508595611431229;
    uint256 constant IC31y = 11430245237396525255066869057828647862629320929803294086464943354492729674880;
    
    uint256 constant IC32x = 9636425178150084378180511444403851322383021851328740780430889767622247177502;
    uint256 constant IC32y = 19951406386629618376511022195531518720751298664906295000638275305433746177337;
    
    uint256 constant IC33x = 12370537533141663672142811143594392597616353640768351608854914286416511069527;
    uint256 constant IC33y = 18777840617364330477246824330589424276245322214551230975549707509256310518877;
    
    uint256 constant IC34x = 15038805455126231770506445527018863602925759004592146953397284781012416003050;
    uint256 constant IC34y = 19311559771977419789799235418492514534072047997686282622195856612433011414874;
    
    uint256 constant IC35x = 19897832817017112363011720814889703894834338807534647053355958649407020776908;
    uint256 constant IC35y = 13080995354092724852891096715904119927089768732696710071154429716883791768629;
    
    uint256 constant IC36x = 15901009183345141539814049282884694152488890407300911403202528347160336510073;
    uint256 constant IC36y = 21361359933783109793577146347723926625133092751545858155067647009912826871597;
    
    uint256 constant IC37x = 15790476229781757477909167804466463271598663833401200728924100171496965283702;
    uint256 constant IC37y = 20854261006261687260198472863243751944713506407532061794959171870727446983374;
    
    uint256 constant IC38x = 20101243632200183643002439438955070208922158840418508286397921513482263038302;
    uint256 constant IC38y = 429816269435240786965616772071616084195551896967900169661021574604285280103;
    
    uint256 constant IC39x = 14334879029552157219191689355567059054560024241657181251260611762660645518441;
    uint256 constant IC39y = 4719383723669382094724922765254668456740202112448855067658368781390384739239;
    
    uint256 constant IC40x = 2405761076229553098030803291174336488183744044333261933016305758808689868308;
    uint256 constant IC40y = 899201286335725841306026879671183953574191373136665081455740797948150204867;
    
    uint256 constant IC41x = 1975308292585076381840295726898826340265236729207305209135146730216847420448;
    uint256 constant IC41y = 9438310735540034460487664095006640047667096122038246848573438620932108655350;
    
    uint256 constant IC42x = 9368782106133120511695466493533305138174075840476852414198063489453387164862;
    uint256 constant IC42y = 17791175292747173000024612279845906656612592697784368304439032429753451959506;
    
    uint256 constant IC43x = 21549915233646267728928344540226278521838944938726575827284289567380257333055;
    uint256 constant IC43y = 17508690313095810963895390279689168338206400642070088097506151076398700838950;
    
    uint256 constant IC44x = 12178245119487180363021753216904946709977713235565966571596704437797540019736;
    uint256 constant IC44y = 5726876829670159051246004547738116878986836238117115122820181744617031311651;
    
    uint256 constant IC45x = 7431078345840617554721447612477575803639111937141348004463895488059872186225;
    uint256 constant IC45y = 12265146322746790749107082976093701537404482750930169634778758693825828360554;
    
    uint256 constant IC46x = 3758899149796355463401821455873271796500880863829115175034268878057019410983;
    uint256 constant IC46y = 6529003626883619143439207636300383025402132412438195110037612704018980166225;
    
    uint256 constant IC47x = 21816983511015087009443969229360599783513664610481010502801662310608965305731;
    uint256 constant IC47y = 1802319973993207409696363605032499582074887594149749750917353626830281783596;
    
    uint256 constant IC48x = 7239466529437268274483598236417370575317113725154296771916369420444423591913;
    uint256 constant IC48y = 19225865019239343644577073240886414139324115550927036878783227465763639336520;
    
    uint256 constant IC49x = 17873675425283681931396838747227484713113046614106872977358305431089796025762;
    uint256 constant IC49y = 860054496796541569874465248155095048850317460076224703495171650936246560360;
    
    uint256 constant IC50x = 12464047486972472750949615461203448172704749357101217892250105889684765517706;
    uint256 constant IC50y = 11207779392836237432398393655167576676938490151131801846998921250440122215614;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[50] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                
                g1_mulAccC(_pVk, IC33x, IC33y, calldataload(add(pubSignals, 1024)))
                
                g1_mulAccC(_pVk, IC34x, IC34y, calldataload(add(pubSignals, 1056)))
                
                g1_mulAccC(_pVk, IC35x, IC35y, calldataload(add(pubSignals, 1088)))
                
                g1_mulAccC(_pVk, IC36x, IC36y, calldataload(add(pubSignals, 1120)))
                
                g1_mulAccC(_pVk, IC37x, IC37y, calldataload(add(pubSignals, 1152)))
                
                g1_mulAccC(_pVk, IC38x, IC38y, calldataload(add(pubSignals, 1184)))
                
                g1_mulAccC(_pVk, IC39x, IC39y, calldataload(add(pubSignals, 1216)))
                
                g1_mulAccC(_pVk, IC40x, IC40y, calldataload(add(pubSignals, 1248)))
                
                g1_mulAccC(_pVk, IC41x, IC41y, calldataload(add(pubSignals, 1280)))
                
                g1_mulAccC(_pVk, IC42x, IC42y, calldataload(add(pubSignals, 1312)))
                
                g1_mulAccC(_pVk, IC43x, IC43y, calldataload(add(pubSignals, 1344)))
                
                g1_mulAccC(_pVk, IC44x, IC44y, calldataload(add(pubSignals, 1376)))
                
                g1_mulAccC(_pVk, IC45x, IC45y, calldataload(add(pubSignals, 1408)))
                
                g1_mulAccC(_pVk, IC46x, IC46y, calldataload(add(pubSignals, 1440)))
                
                g1_mulAccC(_pVk, IC47x, IC47y, calldataload(add(pubSignals, 1472)))
                
                g1_mulAccC(_pVk, IC48x, IC48y, calldataload(add(pubSignals, 1504)))
                
                g1_mulAccC(_pVk, IC49x, IC49y, calldataload(add(pubSignals, 1536)))
                
                g1_mulAccC(_pVk, IC50x, IC50y, calldataload(add(pubSignals, 1568)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            
            checkField(calldataload(add(_pubSignals, 1024)))
            
            checkField(calldataload(add(_pubSignals, 1056)))
            
            checkField(calldataload(add(_pubSignals, 1088)))
            
            checkField(calldataload(add(_pubSignals, 1120)))
            
            checkField(calldataload(add(_pubSignals, 1152)))
            
            checkField(calldataload(add(_pubSignals, 1184)))
            
            checkField(calldataload(add(_pubSignals, 1216)))
            
            checkField(calldataload(add(_pubSignals, 1248)))
            
            checkField(calldataload(add(_pubSignals, 1280)))
            
            checkField(calldataload(add(_pubSignals, 1312)))
            
            checkField(calldataload(add(_pubSignals, 1344)))
            
            checkField(calldataload(add(_pubSignals, 1376)))
            
            checkField(calldataload(add(_pubSignals, 1408)))
            
            checkField(calldataload(add(_pubSignals, 1440)))
            
            checkField(calldataload(add(_pubSignals, 1472)))
            
            checkField(calldataload(add(_pubSignals, 1504)))
            
            checkField(calldataload(add(_pubSignals, 1536)))
            
            checkField(calldataload(add(_pubSignals, 1568)))
            
            checkField(calldataload(add(_pubSignals, 1600)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }


// File contracts/Nft_4_20Verifier.sol

// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 166729475764742472551909953459555984959117340099301140395341278204528677150;
    uint256 constant deltax2 = 11464152730085740304873700030159637101358220670053370543182122231732633047866;
    uint256 constant deltay1 = 484747097008269343046888714110515468952732269253068350124708227896721985327;
    uint256 constant deltay2 = 9433804095746813112897152094194491825239492701117910147687933500651246045978;

    
    uint256 constant IC0x = 6803534104668391709447170165007045078999892925608388926799595914660799746769;
    uint256 constant IC0y = 18412270423633390699496432853664296687884451473695007418790263785070207972045;
    
    uint256 constant IC1x = 19034105411645890081875374219746285853432421516971410381660424676639153509350;
    uint256 constant IC1y = 18672700598039293516979316256079673342888419950179004512758476103206772145123;
    
    uint256 constant IC2x = 2598617520348231364348901926871437390444974427158745363750946364734921874086;
    uint256 constant IC2y = 2089017966694923933645663071459381907630289419858117941268259274994422703229;
    
    uint256 constant IC3x = 2379561561102536175641265522634060417746215782579466042735714312870791196692;
    uint256 constant IC3y = 18246807625011160841800900505174620880968223494969215636448049908410012601524;
    
    uint256 constant IC4x = 10335171730045419531102983400355424492538462710073413340845290186961921549453;
    uint256 constant IC4y = 1069572073474459095993552983804190370281351382646918538773902638322658875119;
    
    uint256 constant IC5x = 10718664570833526468371552674380887537576524717524439302681894155873759986462;
    uint256 constant IC5y = 17263347470110977762624921351234689368863594856058107229083342204130037543833;
    
    uint256 constant IC6x = 10669283243987143083971007605880867545285326205761423872275849121205621849392;
    uint256 constant IC6y = 81231192284715147770749748554523450033418616744177124468780200359537807055;
    
    uint256 constant IC7x = 18672207415914514936803402643594206439591161459111350643400891722533215486729;
    uint256 constant IC7y = 1729400479489627385523470092248448038235818602366585249432050354520253873388;
    
    uint256 constant IC8x = 10589929718781859187113851636611504630691549043860683859915234415534942192870;
    uint256 constant IC8y = 5143161803464793360121123027280408536609758001731130619086058885593270652703;
    
    uint256 constant IC9x = 6203261732884069742202047287806833595427841264419211987490887226104516337199;
    uint256 constant IC9y = 4884322981138167146116901799914959957155248701823814423593093497390274984949;
    
    uint256 constant IC10x = 21841311863966479608619978436173695700108735740134082795095638096800352038015;
    uint256 constant IC10y = 10450971886300004016458453333657281725625085973011811550772337359277983143125;
    
    uint256 constant IC11x = 7448086254836196719449773421972435741854527350389414245951723229049582657822;
    uint256 constant IC11y = 21769396790058407165283577684077594550430174450916279784341977665088651527542;
    
    uint256 constant IC12x = 15343082790396226054304596673148566109260162829703650457908412992383580763450;
    uint256 constant IC12y = 6939754683075990853870949683163681169057287055623257937315604940904500598488;
    
    uint256 constant IC13x = 18532365167873478647228281101492373775344021660111475480264514652930871588787;
    uint256 constant IC13y = 7577170110848204663323596977219545859023485199904679660111144527162144858702;
    
    uint256 constant IC14x = 20272496941050427161937776184072826893580839222876156751340289076283457845113;
    uint256 constant IC14y = 6947536237496082006931372301313167702630019433499825807230521636116436496263;
    
    uint256 constant IC15x = 15832651593623074600825853087652353270643264737395605596794435550838485355144;
    uint256 constant IC15y = 16827035707849960311839174956844435243384594579164355725878243317143143093897;
    
    uint256 constant IC16x = 17517423579609638598825126171273827175832949010336827028637259835386579732223;
    uint256 constant IC16y = 18245343776335095615489740253723244442136567448934194499240144084207911266438;
    
    uint256 constant IC17x = 18429348887907673342424972463989570063003143977440807808995238388295352589604;
    uint256 constant IC17y = 8852819755815965775878640839699039280905552127788956528089945058965919806722;
    
    uint256 constant IC18x = 11659863449094650866511285379681963585489519722669082635355609033639220787058;
    uint256 constant IC18y = 15097098371024872668161287991671010925741747542150163474265029938685102987237;
    
    uint256 constant IC19x = 13514679291677087940360954221269010122013132909364216177201965386061570355472;
    uint256 constant IC19y = 450130294940327961926013929897074472683942832315812485732598578304260237233;
    
    uint256 constant IC20x = 19659127175968195486670501131254880204937844122628939472913084191518431167841;
    uint256 constant IC20y = 19674742802065010070940064840738748904947937939821288933012320696631203686704;
    
    uint256 constant IC21x = 4606474550796142466676310120427189449921680195356889581462263258945288069106;
    uint256 constant IC21y = 15292746454982484332698624922312130817149038527351522271382467785484625155973;
    
    uint256 constant IC22x = 20230344458014116525525422407170475498298788036146823961580001675263939286664;
    uint256 constant IC22y = 13533326137836915567678943317347384570630743175360944849228418262741767949089;
    
    uint256 constant IC23x = 8143787447143611238594286361809558113219193139629632107385643513451830964460;
    uint256 constant IC23y = 11641865818768734612698451709543177068916361867085594085195697834231908677842;
    
    uint256 constant IC24x = 9448530824248342397062594343104556393301111358918819667612250401814512856722;
    uint256 constant IC24y = 20969068631375605665724850066706393671066928891876689969622640600895548858297;
    
    uint256 constant IC25x = 18305952422235720278971027337842209196092181284114301906920770436751863818359;
    uint256 constant IC25y = 20204480773318255272393376528010469964511200658961071316020536363961811364106;
    
    uint256 constant IC26x = 19146281366048808770070648396078969604673276840371791033926696417766419469144;
    uint256 constant IC26y = 16669539566834957832687165106801540983197061433734904879135539184412247607044;
    
    uint256 constant IC27x = 19320670414981064060377999292485399353632171866423342652228888789388421373265;
    uint256 constant IC27y = 21611820786408096828077460837029980799425262023410623678598393435469059715165;
    
    uint256 constant IC28x = 14836513190265515971321494616410780046916822839497886990364132616323677701957;
    uint256 constant IC28y = 12812981293486880144497737756678267146492165094310209171709665322948946095246;
    
    uint256 constant IC29x = 20813824641241866951989184520198943959895596257443877838933698314260602118472;
    uint256 constant IC29y = 16572267762286478614927758286532039409494333314409614436900368081115855733789;
    
    uint256 constant IC30x = 17077224324118597059863514907613815646626668185882691614502453179121085406131;
    uint256 constant IC30y = 18614339567559039785222721147446259601375867401187473431890914152299377649665;
    
    uint256 constant IC31x = 15530490571551471182947675078763210950873390045320095479430251623305633168577;
    uint256 constant IC31y = 8043684678265057452190306753721716429712240776354211614293660203515870519332;
    
    uint256 constant IC32x = 12021491326989648147732479510923424309902883620576487826062104350685437938903;
    uint256 constant IC32y = 17763602669782088568159541559853083978259401723100137679167931722260739732339;
    
    uint256 constant IC33x = 13639684408825126496573309002475079394262088521082329324554327183805035251519;
    uint256 constant IC33y = 6461525206862177491031536304433845452485189515467722694986574241903707869794;
    
    uint256 constant IC34x = 19810470948934188063539688526820912506958188774473937743419226060824480539961;
    uint256 constant IC34y = 9342573142153195172557341761237381429342073967744424330924094932862418291579;
    
    uint256 constant IC35x = 7915239645088706694171574837005964727163796131074501245139102405324158482925;
    uint256 constant IC35y = 2360565054800004615218262957452522085106655205496177643499960485061105997933;
    
    uint256 constant IC36x = 13455315001800865522161260183786212425315526813513537942903662854283749095736;
    uint256 constant IC36y = 10723047632097086867954808859319779599381394668209755448177393659883388848286;
    
    uint256 constant IC37x = 6802053108719734017179101278585195543970476276540976308447819915685951575408;
    uint256 constant IC37y = 18500165076070728685270565385179282121866097192855779986233230381871275270477;
    
    uint256 constant IC38x = 18942919158800469759746983611285701647074810591187172848015370920117299055788;
    uint256 constant IC38y = 5487045110693162290470896102312786388285037276857511040332849557300561874422;
    
    uint256 constant IC39x = 3610226443203271384856365580973960512532193089809731338577920264025709978713;
    uint256 constant IC39y = 318751394466165829383366618973134914185632619642435003502538440753299301051;
    
    uint256 constant IC40x = 18076955375239637223208109598018949824163726040013260250896114400911473350977;
    uint256 constant IC40y = 14244437759991686701244913780817947875321923196928914209453121068528765613058;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[40] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                
                g1_mulAccC(_pVk, IC33x, IC33y, calldataload(add(pubSignals, 1024)))
                
                g1_mulAccC(_pVk, IC34x, IC34y, calldataload(add(pubSignals, 1056)))
                
                g1_mulAccC(_pVk, IC35x, IC35y, calldataload(add(pubSignals, 1088)))
                
                g1_mulAccC(_pVk, IC36x, IC36y, calldataload(add(pubSignals, 1120)))
                
                g1_mulAccC(_pVk, IC37x, IC37y, calldataload(add(pubSignals, 1152)))
                
                g1_mulAccC(_pVk, IC38x, IC38y, calldataload(add(pubSignals, 1184)))
                
                g1_mulAccC(_pVk, IC39x, IC39y, calldataload(add(pubSignals, 1216)))
                
                g1_mulAccC(_pVk, IC40x, IC40y, calldataload(add(pubSignals, 1248)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            
            checkField(calldataload(add(_pubSignals, 1024)))
            
            checkField(calldataload(add(_pubSignals, 1056)))
            
            checkField(calldataload(add(_pubSignals, 1088)))
            
            checkField(calldataload(add(_pubSignals, 1120)))
            
            checkField(calldataload(add(_pubSignals, 1152)))
            
            checkField(calldataload(add(_pubSignals, 1184)))
            
            checkField(calldataload(add(_pubSignals, 1216)))
            
            checkField(calldataload(add(_pubSignals, 1248)))
            
            checkField(calldataload(add(_pubSignals, 1280)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }


// File contracts/Nft_8_20Verifier.sol

// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 15457291534510120960344947191359464626839000337312657357714721892248977325053;
    uint256 constant deltax2 = 15345665386383357885868377415425379295667103281345602440867145992166524748273;
    uint256 constant deltay1 = 8456171333599364617240640905505951023384546621593357358521596718537077294751;
    uint256 constant deltay2 = 8929238422183677512929159867910260162470319442391845796008350555576398842343;

    
    uint256 constant IC0x = 12072436980709015507743780014847031858892969511666466132421147064336235643957;
    uint256 constant IC0y = 20654143443031433362627129017967674094486466179433934185527905810081202077193;
    
    uint256 constant IC1x = 1728501196183726608611630394179127901128384900459013304840857961319372569737;
    uint256 constant IC1y = 7629678571759514117803636295544191871661059326555388594531234453779692315862;
    
    uint256 constant IC2x = 21372097432766233821292783980930679196040195428992670707793165602721480142421;
    uint256 constant IC2y = 9347992726525807476104217035155979684492937050744785020058238222434686131374;
    
    uint256 constant IC3x = 13618565907995956192615952572731907404214828719712845596236280081736094377237;
    uint256 constant IC3y = 16405228702828859436646620863734484791796905135889312158669428620158034022798;
    
    uint256 constant IC4x = 21744512312350264742010149678796025510451251640768586670681056275957390576840;
    uint256 constant IC4y = 6370088214487976300870231286330130323082070834416113904114222037666470469594;
    
    uint256 constant IC5x = 16621639596612931191192982579297853580737444108159180372489166824108102177485;
    uint256 constant IC5y = 1291937150003206509051125895897944022181175715227701833141107064150908851960;
    
    uint256 constant IC6x = 19370787321421176179641871754079699140428250465130540222767836607254892056815;
    uint256 constant IC6y = 19758292259141871089379357595176602670222627626438807690415261894509397152855;
    
    uint256 constant IC7x = 19683132687022901174526238384300490325797012496500673328015843039485278420273;
    uint256 constant IC7y = 17176700649739216725693280382966125256744341693088640744728784133824201986245;
    
    uint256 constant IC8x = 1605161063924468062513949763755983624472730901727487106295588024361564376579;
    uint256 constant IC8y = 15219562253241146047721251072282463119904444867717064859926729600607124142746;
    
    uint256 constant IC9x = 15230861444667461109799443522299434445240139681086684956826793978687625498305;
    uint256 constant IC9y = 433009458166655329094071937024908262318704275172175077586820622753141315586;
    
    uint256 constant IC10x = 910621900436426940640461448733828617988610882231597496594437455851616832288;
    uint256 constant IC10y = 13045379749377209483896510297210101514577981414684858501082702619804225585590;
    
    uint256 constant IC11x = 3432269937047958591122513369807179506245016699502138568205017758517902900578;
    uint256 constant IC11y = 17222750883078448597167677608720360825829159968193723789952980459838079285567;
    
    uint256 constant IC12x = 160283647341296877248775684264193557360440303238565769497188162869656245158;
    uint256 constant IC12y = 20698727742252367088646688871746498590149557606445780243553639403028882657973;
    
    uint256 constant IC13x = 5849933633668384977953520410322836668767579975505605422012927575405557057416;
    uint256 constant IC13y = 7950060632914043133441718203801660077365343532212953480220258523445144887993;
    
    uint256 constant IC14x = 16959836263248439234413909440153810751089107133599885524859720274935124972613;
    uint256 constant IC14y = 5927370131583858947707032946876651012610223135650987809760405997467055763080;
    
    uint256 constant IC15x = 3975769382935191653590522064494677147816190082122180758384848224022983433895;
    uint256 constant IC15y = 8461431007198394783938773086209313190202298657625212962182137894322237949700;
    
    uint256 constant IC16x = 11309481384699675163551378271149036330906587783582098568156350329678272342015;
    uint256 constant IC16y = 14381028955761977476410996351446539015016436299086309177851633772185532706458;
    
    uint256 constant IC17x = 4425897935147648302384729479851789777514711449892435393037592005143806323139;
    uint256 constant IC17y = 13473055808810485047958421976150023329200585970431734517570784841370587623137;
    
    uint256 constant IC18x = 20897227096252064549337587859282223042799803932210574498574969981151270644798;
    uint256 constant IC18y = 18036150631013454789832363754139457120940395960250002290801151158861619412500;
    
    uint256 constant IC19x = 17866371883915923728354016086427458413456606278758834150815009948056722608049;
    uint256 constant IC19y = 13312106082786479429622757022250555035692609893114314503609940869315576965115;
    
    uint256 constant IC20x = 6554141682210134190938061832884586079502135975208968982423550244136332810915;
    uint256 constant IC20y = 12554906916025329392537679542154280666967668119616261373192568878449581362599;
    
    uint256 constant IC21x = 2460733505853272392888338593355920475390120245799251578555006304160011957963;
    uint256 constant IC21y = 14074082953947716400049485813500844863623453234890320173197110015423046429880;
    
    uint256 constant IC22x = 3673471033045437776048316658833359069501702866544766824127601564483387195988;
    uint256 constant IC22y = 21497611624451413687721650731539881723628233905639622284718542670103375258757;
    
    uint256 constant IC23x = 13964738078751071429249144215228216745951476747969661505835527438432600440331;
    uint256 constant IC23y = 5445568833492613356626315009988883156648330109029127715020529027247032225051;
    
    uint256 constant IC24x = 6138271205274438981788012772309103488510636754302828602433036524473172326183;
    uint256 constant IC24y = 16776220865066388171111547391959874035636216112825710541080968972694916480392;
    
    uint256 constant IC25x = 284149711239568943839975800261656089249560345105132637060271245571528031765;
    uint256 constant IC25y = 14446287715274354332867083092343215592964309124569663271062199162584288895491;
    
    uint256 constant IC26x = 737965924452385218602849536637047206505361863354201721423781807107268677208;
    uint256 constant IC26y = 10718116202581941855593279563389579543847338573382897890335481985931492874541;
    
    uint256 constant IC27x = 19292311342879074024165847670158072673905364677324290054953487034397094659452;
    uint256 constant IC27y = 8960924926262177015717389024560228432022342113226833429012235660437533387805;
    
    uint256 constant IC28x = 12328772572933947968305433305705381693222545902748512058918201645201257881001;
    uint256 constant IC28y = 18253517723718118583967517463456916638671449917739484540298580035237000773721;
    
    uint256 constant IC29x = 15166050686886133706429349705483754898411861547040683094133588433239758020925;
    uint256 constant IC29y = 17421183105596088863043754279249591303952534981855474554669176103698999178795;
    
    uint256 constant IC30x = 8108285811531128875220287577047647825397605453370915123051833551717862651936;
    uint256 constant IC30y = 19537119684080263942543728418793709284371565044753518188620408410518122545657;
    
    uint256 constant IC31x = 17155392625331896546744979144934115248561520317112851465058403582410744554158;
    uint256 constant IC31y = 11235270218875435550579827991893805390296883227569558965365563155625182103561;
    
    uint256 constant IC32x = 13872082923279577853036261526470377459773326684445977099404128169012963234958;
    uint256 constant IC32y = 7693674242617187931379054983341687759889292844024364704153571354189317378860;
    
    uint256 constant IC33x = 3512205478736887014673165766501102749425835894994889461223005004928934319385;
    uint256 constant IC33y = 20374586197489167507000291346136965776667858128861097687008241518700460582232;
    
    uint256 constant IC34x = 16359083230678918552311045326042388506585253186629718255368020483030599527862;
    uint256 constant IC34y = 1010784476153271755310839342483909165273265376336339924262946825293305198615;
    
    uint256 constant IC35x = 12261231959338508896527705462892353197861260969112689939950330035643932237476;
    uint256 constant IC35y = 16285806769716987406515564205642542772727940133823173341306504002970527284892;
    
    uint256 constant IC36x = 8376629511360056917319063177305041285451884297135860235951527142102340326182;
    uint256 constant IC36y = 74706536590046481690955056457053117371769244095676101150038489932495731997;
    
    uint256 constant IC37x = 20056471405880566926875970970908162506873344636495527311480629310248038749523;
    uint256 constant IC37y = 19452268517420645872426548732748521504723522101827865580271720070486062478019;
    
    uint256 constant IC38x = 21316123287129181462772661814714493471757309380069020482211683826799505258505;
    uint256 constant IC38y = 21842344075834608755295248622224792984043459661704819852654618912543784911289;
    
    uint256 constant IC39x = 9225409357209013654146123436378193901125372352272953281483711859230133664149;
    uint256 constant IC39y = 7152830708170937763304742962054132527251463052878060938538277125952935783791;
    
    uint256 constant IC40x = 15306568528921707986043179438317172913337248460887681095348318863350413523913;
    uint256 constant IC40y = 20183061904574668609431447969622533984140563718242154079533802710426772996587;
    
    uint256 constant IC41x = 13687396505400049063992070195835756253357404113195701703533383220155831777394;
    uint256 constant IC41y = 13366046792245406905266842981530948831240522340939034725730770490214020619017;
    
    uint256 constant IC42x = 2396922935244159388563330447431734267225310340477314881430172433719955094062;
    uint256 constant IC42y = 10212012647276086558182383083523572806444308729780803355925131471515495865504;
    
    uint256 constant IC43x = 8552167178852906104490747500154498829828784741427076166775387134713417995539;
    uint256 constant IC43y = 8248471598241529509484434549857748974852682375171713796236602540143415604190;
    
    uint256 constant IC44x = 7237998658289648744952219123027850992491638283010821034975742541370556547063;
    uint256 constant IC44y = 8081259404586843565862003686647189363520308292813458025908335789162351699839;
    
    uint256 constant IC45x = 5161413458737763005656079009926511455666896895394709490973002937145548204346;
    uint256 constant IC45y = 16302638640356871247283685401476947283752319290775291976301589901059437889782;
    
    uint256 constant IC46x = 2225584722957294784720809440587266866373377830334412559526677681159558913012;
    uint256 constant IC46y = 19003393986251527581769853864263344545570312619738441312056854710215219452330;
    
    uint256 constant IC47x = 3167764064310813530733608258615404192566726240326546657775081344890129409941;
    uint256 constant IC47y = 4329214500186851881651745320394197767293069602811192075484315505306179699120;
    
    uint256 constant IC48x = 14576814326851086179628221073823751402597216314056465100508418034013283786105;
    uint256 constant IC48y = 6970468275090209983899935923109023311031545573189437985783219673231673874643;
    
    uint256 constant IC49x = 20471087692300949980907727523534682997845958007467175085503147210332961341713;
    uint256 constant IC49y = 14609520971464593252535538887815612474477988991925019146351063557583664011209;
    
    uint256 constant IC50x = 16687077563481720878387961458088633081860322516245004191930563989722413210088;
    uint256 constant IC50y = 5350555230076930487685121831412716152202023430645397047283505904846319299474;
    
    uint256 constant IC51x = 21048350790463227940642605017467775148513716680027861995595894601805170536897;
    uint256 constant IC51y = 17546825414571608770434622833234088923598629560620150266046628784209512922317;
    
    uint256 constant IC52x = 16033352917698775362151971118464805071687298614126788567743992479184903388715;
    uint256 constant IC52y = 2292361005186317237465976981532167228206701287739320827280336524189316815799;
    
    uint256 constant IC53x = 19512629021754569382414001242345992031094435750314973420603752404562745823418;
    uint256 constant IC53y = 1436831540061075489477638678538179342221044370456363805347434357109159608153;
    
    uint256 constant IC54x = 15789361624737609944405746915179689109737275601168569541904699615057673012577;
    uint256 constant IC54y = 4023103060058424259244106616292398360788905918020892449154163973253077514140;
    
    uint256 constant IC55x = 13981707539221978394180571873768527013770290244140660338356709864049955080825;
    uint256 constant IC55y = 19202471265517611925720663718659404814437621126689247487899378411108884593252;
    
    uint256 constant IC56x = 1736483801050153554809762444537165976612352217751069169925279687266026617547;
    uint256 constant IC56y = 11991741902345138168702578991299190086151716470798555466311321443477290484493;
    
    uint256 constant IC57x = 1941933318601473561826160317956913879516604360917873597526880424161489975144;
    uint256 constant IC57y = 16769206267087306934785956391838660940491673728486591995274771664302389353478;
    
    uint256 constant IC58x = 2330247141303996366114135239983420600178124203032892337302241687818644342020;
    uint256 constant IC58y = 12919435116545120534942944199177582440390304652203606589144989899589840489194;
    
    uint256 constant IC59x = 15807649035284768863070883591343726771637599019463393894460635946344377227783;
    uint256 constant IC59y = 18849615482461284918108768649745076141633526273023909920046207309268924556861;
    
    uint256 constant IC60x = 8047537224709835640738371542925577322178208483746740301070121196512671868620;
    uint256 constant IC60y = 5764549731666110268045370741501726114061254909475752408699283758105258685974;
    
    uint256 constant IC61x = 19317491804949123422177573838017266111245353002979946647044779275963762107306;
    uint256 constant IC61y = 12305793383979957578012250774803550906020290381151401361723303302028423836186;
    
    uint256 constant IC62x = 9615212816099983748764502198529523249974450073843379747632610425248860001607;
    uint256 constant IC62y = 8034090943290563845782201328256769171074189337878378256693840757203334062652;
    
    uint256 constant IC63x = 8237080814712127401133833990458529998451927136487507224001489613514458155055;
    uint256 constant IC63y = 11495022843788744511647861167127325838156085342725741618927062329357056260097;
    
    uint256 constant IC64x = 21008785371566637923621486026628788103240735256202169333457567887860681509996;
    uint256 constant IC64y = 9086195759368691340247299155405949984282115939394062916035862242892437300678;
    
    uint256 constant IC65x = 11409082438245395168351505866714656610511084068267628452550901333981410832189;
    uint256 constant IC65y = 8911124948528303209194421942558237050816630287806596397195348784378520101097;
    
    uint256 constant IC66x = 2266542245759420027987961368836931634339929622402657661531003957048348824006;
    uint256 constant IC66y = 18681450446996975065432589895977552904847179860844169478615315886266698416785;
    
    uint256 constant IC67x = 13105954286502121108563462882134083837876664509943125671015429077889561851678;
    uint256 constant IC67y = 9415430056845662494135699813419902643451964682835446066292894044988682432626;
    
    uint256 constant IC68x = 2412837582478375809550693953553884497905438970037381444542763960536993316787;
    uint256 constant IC68y = 19292756503019777159192019594504505163915105951495226679097464991048985116389;
    
    uint256 constant IC69x = 18473996186845183665654693956877338310595056376750668985982369188350396614402;
    uint256 constant IC69y = 21752655286241851275269759873879404665412224558257730879161360478620739184193;
    
    uint256 constant IC70x = 3776042270089471829091414631283240001931067995976838988429158159526216037231;
    uint256 constant IC70y = 21109051161678595288730480588163408381113248823801961781513570163260432506333;
    
    uint256 constant IC71x = 10391199449193477701043599554470038679127797915492557083642295893823048540940;
    uint256 constant IC71y = 17817429769342470403181937922156295908619149480506211816499318857238908258735;
    
    uint256 constant IC72x = 18321070386207782727387937915203779874295230172486998894505255598325104233380;
    uint256 constant IC72y = 6228062389921808543921873114954354043780473328352865186947205977803606338101;
    
    uint256 constant IC73x = 13078070766619258779015819883090782830666022443188009666875148375728588624534;
    uint256 constant IC73y = 6206052556988802432570334537587381345298346689384826793508746326601032637927;
    
    uint256 constant IC74x = 12469353408916401343549652315481893357173237983574531603887317116666176407143;
    uint256 constant IC74y = 556593801865932188393257586461762655767984698498520037835783647720492317874;
    
    uint256 constant IC75x = 15471181766426641044543222698670325084987872159934148892696355446678300224739;
    uint256 constant IC75y = 1339102751819805737008970489764772666438978869175296196347530980778289866327;
    
    uint256 constant IC76x = 8013312849849638976194741310236631416024021979814033401010883071661710628896;
    uint256 constant IC76y = 14883885134089271668801003104040689418552781318889194646265443952614025867833;
    
    uint256 constant IC77x = 936776284369141089921927983300584645314706791860817882053218494490705763523;
    uint256 constant IC77y = 15043645724607898371753924471521137385814325550972563735731655186669667218377;
    
    uint256 constant IC78x = 10945183315648827568686041350794123009338596827948838304869234540635331137274;
    uint256 constant IC78y = 6672366809375423144243745390641807730493702679288312320033985844971888652118;
    
    uint256 constant IC79x = 16160547084906928063725176172224003801463100881339373164851235586063673667421;
    uint256 constant IC79y = 19658782597959912628114687252457123705511563091379548994629490968280041950982;
    
    uint256 constant IC80x = 20144201516232615207828524923607854835550684824427701404203175097161252146794;
    uint256 constant IC80y = 17127617079424621772374863080554989315818065235472043858422881108693426377211;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[80] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                
                g1_mulAccC(_pVk, IC33x, IC33y, calldataload(add(pubSignals, 1024)))
                
                g1_mulAccC(_pVk, IC34x, IC34y, calldataload(add(pubSignals, 1056)))
                
                g1_mulAccC(_pVk, IC35x, IC35y, calldataload(add(pubSignals, 1088)))
                
                g1_mulAccC(_pVk, IC36x, IC36y, calldataload(add(pubSignals, 1120)))
                
                g1_mulAccC(_pVk, IC37x, IC37y, calldataload(add(pubSignals, 1152)))
                
                g1_mulAccC(_pVk, IC38x, IC38y, calldataload(add(pubSignals, 1184)))
                
                g1_mulAccC(_pVk, IC39x, IC39y, calldataload(add(pubSignals, 1216)))
                
                g1_mulAccC(_pVk, IC40x, IC40y, calldataload(add(pubSignals, 1248)))
                
                g1_mulAccC(_pVk, IC41x, IC41y, calldataload(add(pubSignals, 1280)))
                
                g1_mulAccC(_pVk, IC42x, IC42y, calldataload(add(pubSignals, 1312)))
                
                g1_mulAccC(_pVk, IC43x, IC43y, calldataload(add(pubSignals, 1344)))
                
                g1_mulAccC(_pVk, IC44x, IC44y, calldataload(add(pubSignals, 1376)))
                
                g1_mulAccC(_pVk, IC45x, IC45y, calldataload(add(pubSignals, 1408)))
                
                g1_mulAccC(_pVk, IC46x, IC46y, calldataload(add(pubSignals, 1440)))
                
                g1_mulAccC(_pVk, IC47x, IC47y, calldataload(add(pubSignals, 1472)))
                
                g1_mulAccC(_pVk, IC48x, IC48y, calldataload(add(pubSignals, 1504)))
                
                g1_mulAccC(_pVk, IC49x, IC49y, calldataload(add(pubSignals, 1536)))
                
                g1_mulAccC(_pVk, IC50x, IC50y, calldataload(add(pubSignals, 1568)))
                
                g1_mulAccC(_pVk, IC51x, IC51y, calldataload(add(pubSignals, 1600)))
                
                g1_mulAccC(_pVk, IC52x, IC52y, calldataload(add(pubSignals, 1632)))
                
                g1_mulAccC(_pVk, IC53x, IC53y, calldataload(add(pubSignals, 1664)))
                
                g1_mulAccC(_pVk, IC54x, IC54y, calldataload(add(pubSignals, 1696)))
                
                g1_mulAccC(_pVk, IC55x, IC55y, calldataload(add(pubSignals, 1728)))
                
                g1_mulAccC(_pVk, IC56x, IC56y, calldataload(add(pubSignals, 1760)))
                
                g1_mulAccC(_pVk, IC57x, IC57y, calldataload(add(pubSignals, 1792)))
                
                g1_mulAccC(_pVk, IC58x, IC58y, calldataload(add(pubSignals, 1824)))
                
                g1_mulAccC(_pVk, IC59x, IC59y, calldataload(add(pubSignals, 1856)))
                
                g1_mulAccC(_pVk, IC60x, IC60y, calldataload(add(pubSignals, 1888)))
                
                g1_mulAccC(_pVk, IC61x, IC61y, calldataload(add(pubSignals, 1920)))
                
                g1_mulAccC(_pVk, IC62x, IC62y, calldataload(add(pubSignals, 1952)))
                
                g1_mulAccC(_pVk, IC63x, IC63y, calldataload(add(pubSignals, 1984)))
                
                g1_mulAccC(_pVk, IC64x, IC64y, calldataload(add(pubSignals, 2016)))
                
                g1_mulAccC(_pVk, IC65x, IC65y, calldataload(add(pubSignals, 2048)))
                
                g1_mulAccC(_pVk, IC66x, IC66y, calldataload(add(pubSignals, 2080)))
                
                g1_mulAccC(_pVk, IC67x, IC67y, calldataload(add(pubSignals, 2112)))
                
                g1_mulAccC(_pVk, IC68x, IC68y, calldataload(add(pubSignals, 2144)))
                
                g1_mulAccC(_pVk, IC69x, IC69y, calldataload(add(pubSignals, 2176)))
                
                g1_mulAccC(_pVk, IC70x, IC70y, calldataload(add(pubSignals, 2208)))
                
                g1_mulAccC(_pVk, IC71x, IC71y, calldataload(add(pubSignals, 2240)))
                
                g1_mulAccC(_pVk, IC72x, IC72y, calldataload(add(pubSignals, 2272)))
                
                g1_mulAccC(_pVk, IC73x, IC73y, calldataload(add(pubSignals, 2304)))
                
                g1_mulAccC(_pVk, IC74x, IC74y, calldataload(add(pubSignals, 2336)))
                
                g1_mulAccC(_pVk, IC75x, IC75y, calldataload(add(pubSignals, 2368)))
                
                g1_mulAccC(_pVk, IC76x, IC76y, calldataload(add(pubSignals, 2400)))
                
                g1_mulAccC(_pVk, IC77x, IC77y, calldataload(add(pubSignals, 2432)))
                
                g1_mulAccC(_pVk, IC78x, IC78y, calldataload(add(pubSignals, 2464)))
                
                g1_mulAccC(_pVk, IC79x, IC79y, calldataload(add(pubSignals, 2496)))
                
                g1_mulAccC(_pVk, IC80x, IC80y, calldataload(add(pubSignals, 2528)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            
            checkField(calldataload(add(_pubSignals, 1024)))
            
            checkField(calldataload(add(_pubSignals, 1056)))
            
            checkField(calldataload(add(_pubSignals, 1088)))
            
            checkField(calldataload(add(_pubSignals, 1120)))
            
            checkField(calldataload(add(_pubSignals, 1152)))
            
            checkField(calldataload(add(_pubSignals, 1184)))
            
            checkField(calldataload(add(_pubSignals, 1216)))
            
            checkField(calldataload(add(_pubSignals, 1248)))
            
            checkField(calldataload(add(_pubSignals, 1280)))
            
            checkField(calldataload(add(_pubSignals, 1312)))
            
            checkField(calldataload(add(_pubSignals, 1344)))
            
            checkField(calldataload(add(_pubSignals, 1376)))
            
            checkField(calldataload(add(_pubSignals, 1408)))
            
            checkField(calldataload(add(_pubSignals, 1440)))
            
            checkField(calldataload(add(_pubSignals, 1472)))
            
            checkField(calldataload(add(_pubSignals, 1504)))
            
            checkField(calldataload(add(_pubSignals, 1536)))
            
            checkField(calldataload(add(_pubSignals, 1568)))
            
            checkField(calldataload(add(_pubSignals, 1600)))
            
            checkField(calldataload(add(_pubSignals, 1632)))
            
            checkField(calldataload(add(_pubSignals, 1664)))
            
            checkField(calldataload(add(_pubSignals, 1696)))
            
            checkField(calldataload(add(_pubSignals, 1728)))
            
            checkField(calldataload(add(_pubSignals, 1760)))
            
            checkField(calldataload(add(_pubSignals, 1792)))
            
            checkField(calldataload(add(_pubSignals, 1824)))
            
            checkField(calldataload(add(_pubSignals, 1856)))
            
            checkField(calldataload(add(_pubSignals, 1888)))
            
            checkField(calldataload(add(_pubSignals, 1920)))
            
            checkField(calldataload(add(_pubSignals, 1952)))
            
            checkField(calldataload(add(_pubSignals, 1984)))
            
            checkField(calldataload(add(_pubSignals, 2016)))
            
            checkField(calldataload(add(_pubSignals, 2048)))
            
            checkField(calldataload(add(_pubSignals, 2080)))
            
            checkField(calldataload(add(_pubSignals, 2112)))
            
            checkField(calldataload(add(_pubSignals, 2144)))
            
            checkField(calldataload(add(_pubSignals, 2176)))
            
            checkField(calldataload(add(_pubSignals, 2208)))
            
            checkField(calldataload(add(_pubSignals, 2240)))
            
            checkField(calldataload(add(_pubSignals, 2272)))
            
            checkField(calldataload(add(_pubSignals, 2304)))
            
            checkField(calldataload(add(_pubSignals, 2336)))
            
            checkField(calldataload(add(_pubSignals, 2368)))
            
            checkField(calldataload(add(_pubSignals, 2400)))
            
            checkField(calldataload(add(_pubSignals, 2432)))
            
            checkField(calldataload(add(_pubSignals, 2464)))
            
            checkField(calldataload(add(_pubSignals, 2496)))
            
            checkField(calldataload(add(_pubSignals, 2528)))
            
            checkField(calldataload(add(_pubSignals, 2560)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }


// File contracts/Nft_7_20Verifier.sol

// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 6560448797999789516893294904465851021179835380528784798864914075619170677970;
    uint256 constant deltax2 = 18066478241213500994794940562359697508688453323259192532840551609195650589222;
    uint256 constant deltay1 = 16701896002766049842235305560239474992191902519555944753480046555937861325901;
    uint256 constant deltay2 = 7880576397533841781302115261360954777830083347661510903382579006754245543973;

    
    uint256 constant IC0x = 11384822543869127560943805415780101397535337868435355729023027388042522600289;
    uint256 constant IC0y = 12400915356802881502845152867751050756127988209926444397800557001515762963148;
    
    uint256 constant IC1x = 4381929240057749499390397473061802685870329685076018129719880316757333360825;
    uint256 constant IC1y = 14021633572433257288450036640372117958522360200473509669907753048643726289025;
    
    uint256 constant IC2x = 18566255967560677471327507371657924607578343615007713154413306661742217812496;
    uint256 constant IC2y = 12493966250082753901930940740327839861626556837546822773504057123472870819716;
    
    uint256 constant IC3x = 14798986504211771393585963082105880564364609916749862132774719152266634690443;
    uint256 constant IC3y = 15020963032869919845277370869338828533097268187943544060727496535063698362140;
    
    uint256 constant IC4x = 4707609194194184160127841784069932580187953219229669342726331642824614212966;
    uint256 constant IC4y = 16695715049538312136532838829116478800608174175336446956732432306278670683434;
    
    uint256 constant IC5x = 21432214085218331926151553554586323018800285499872794599385861668404843701459;
    uint256 constant IC5y = 12931802225507759794045051837631771059700510860104909223112424195608181243315;
    
    uint256 constant IC6x = 11204962704077601992167251865433909437287363375121689751803613491182210417275;
    uint256 constant IC6y = 2790659674341216430959741521504108324315717237601309233869600283460030215195;
    
    uint256 constant IC7x = 19965830615545290477820446669504789436086413734244172359882723453793102896618;
    uint256 constant IC7y = 10983265354615699084133103151168175710460811424795637891144021954412673391196;
    
    uint256 constant IC8x = 18497971836696907749380080785788822104743125313553668775417811649931233395673;
    uint256 constant IC8y = 17863379483594531807321865801530504708606332121423654108276767838627882681592;
    
    uint256 constant IC9x = 19966986116356359129858437580728070323834990638074968356499769353146980376418;
    uint256 constant IC9y = 13799178895256637368111567198210379090041961351311891219563969929345982677078;
    
    uint256 constant IC10x = 5730507730097087256419525295859746887731430555953837344707013630137946936801;
    uint256 constant IC10y = 6331974087439329369183699460821668007653050339306241206826690629018002556164;
    
    uint256 constant IC11x = 6873088042073801334860815306000112218324773934102548023281543219272967695210;
    uint256 constant IC11y = 9204224697431333911055414788294270556487732145035202392960527963254506131388;
    
    uint256 constant IC12x = 21180534592178984674902492562639298938200813390637238594550483991074329757663;
    uint256 constant IC12y = 12813272292759365197329592295111479149827667593512645416034694223954841783799;
    
    uint256 constant IC13x = 6627936000628166521039837090314545292240176828641579000735748459124308390566;
    uint256 constant IC13y = 14814485468357190498582858516869002128872493016643205820408233393767667144668;
    
    uint256 constant IC14x = 13183989981389286116482136492771251200429854863269864512258934579949241075667;
    uint256 constant IC14y = 2737979987010398229778740920841363981434738200098816580381706413132543144330;
    
    uint256 constant IC15x = 12172057242837059259040847965150930470762197391406380831458035475811043286710;
    uint256 constant IC15y = 11655323818520391181454271042170948735082384631508423179325349474538220570095;
    
    uint256 constant IC16x = 2542144019359926138136065802414376296981080942659459828778700708912139608892;
    uint256 constant IC16y = 11562393143673505559525971801851989800113283058674244714809282232808219957090;
    
    uint256 constant IC17x = 3192375885097227684304567947842030133102225698773980752295836997904671379503;
    uint256 constant IC17y = 16122051449277538074719590515766504150338871236971642533014300256907127092085;
    
    uint256 constant IC18x = 17234458580738288790962384595423289518797986538627336117651985516854647082680;
    uint256 constant IC18y = 15377138647741819148476230711189467990273841356537329534757415217894037645868;
    
    uint256 constant IC19x = 17248523863401691516345605797334781468688641239548030526576415483250913154442;
    uint256 constant IC19y = 13623860448544170972230744500505371794749845495437421163941173954114413534296;
    
    uint256 constant IC20x = 20700929555822660911457927512817929904867576800608260384685983728622836310301;
    uint256 constant IC20y = 10796911343715029073392847805926653913953004651811113192309586843421689768337;
    
    uint256 constant IC21x = 1618091654106347828735249693254720801092335070028208381719468125997447554779;
    uint256 constant IC21y = 10821047544318539920283563652952032220095139083267539846601726945289746941786;
    
    uint256 constant IC22x = 12672820512192043449128254776412955281551261194868129399306153567641865547335;
    uint256 constant IC22y = 19862369208426603596682068875448946403952455750217871429276702383163004200352;
    
    uint256 constant IC23x = 19223363048673775532158161572046153518228374680308397322401595895278100122799;
    uint256 constant IC23y = 20833106598669347558244167815398637845065699226686878920071983163926463436912;
    
    uint256 constant IC24x = 12427569819277660140496058678037192072196675815113535851885647930103743615105;
    uint256 constant IC24y = 4726108715539119288351478201843738976161347147885377731384963751027813108925;
    
    uint256 constant IC25x = 12735474308447841092446224483217312894637250935788179038743455742744879234183;
    uint256 constant IC25y = 11288143465606794423618012537216623622067327297243542461885315183275222698557;
    
    uint256 constant IC26x = 2332905362470870761633708510224330326862003431815367545628529801123437092627;
    uint256 constant IC26y = 8132465575227730751781802406762872973254393953950690884406859886840374070553;
    
    uint256 constant IC27x = 2672396586303504187178278490511535568715419882853028196419794506664173175227;
    uint256 constant IC27y = 16171353063396175883082775170785089153462773581037890234990179531988122647820;
    
    uint256 constant IC28x = 14968001571646385025020350730360366226379081067588567588165048663677936407929;
    uint256 constant IC28y = 12774111159629102537198509438097307253903865859314799579937955666452194985973;
    
    uint256 constant IC29x = 3260304431404964909500908202543587856616276533235503868745986307777375630779;
    uint256 constant IC29y = 5844219058078736287964097149958184948630759875495021817151931857044500129098;
    
    uint256 constant IC30x = 10404594557972951580857697867351538483872297084788082036970263121134327411437;
    uint256 constant IC30y = 1236466018424055471347671388457902930093779436944368310506007522402561071942;
    
    uint256 constant IC31x = 11487397339256658950202240206718422328290639747817325737003911118492867785643;
    uint256 constant IC31y = 5311757240199535413361918919188611438846498543277846777850749459600526234595;
    
    uint256 constant IC32x = 4136653757839879172468162118268250367802662919766957632738173386300430833538;
    uint256 constant IC32y = 18390093129372684273481548308457751502955925154555774811739822663923120696712;
    
    uint256 constant IC33x = 3479273183274664184255400670107909510856518794787942825722262800216034608823;
    uint256 constant IC33y = 7057464114125186844302674790996831353271439971499903527440970319688266512412;
    
    uint256 constant IC34x = 18361394645106414813110197300241175039004205794563704060561594276122104980351;
    uint256 constant IC34y = 14143432706891441576545738485418236686339991530841804986936243678381016161239;
    
    uint256 constant IC35x = 12803594528002558511436928263740500444844341720062894194819746140658213601014;
    uint256 constant IC35y = 358413685126939598544287415415649623530431841914448406282559524398772679738;
    
    uint256 constant IC36x = 16722132388607814161397661659806595067670337555214634556026403777986774156994;
    uint256 constant IC36y = 6974081186198709998481824425214256544982712890885967770044230998935136433023;
    
    uint256 constant IC37x = 16587550662307235965036613594485728285535709356185698101464424871265561235674;
    uint256 constant IC37y = 9464221928608219109133094740348355393717728518830796828135914738293016114157;
    
    uint256 constant IC38x = 2773297231588486553684245845287466114023392073838772032347844970296690175638;
    uint256 constant IC38y = 18882453711647904136694308096969272589316023135755688287446556201308464331514;
    
    uint256 constant IC39x = 7141908516643314382340770127432009849114434149352743536897299520097858707917;
    uint256 constant IC39y = 20118597732779757921951631211080066089175783865648651846554077759916069296559;
    
    uint256 constant IC40x = 4448998260366278128831768464711071140025133368918445962126645029138137310853;
    uint256 constant IC40y = 6239316434928394034355434972675086251853106509771862709421983335078488396090;
    
    uint256 constant IC41x = 20308671992781450877067502388348117162469983435492331975686772639855029428919;
    uint256 constant IC41y = 12500561845053138198866311965397096832691868539076755869239307835048337467750;
    
    uint256 constant IC42x = 6826534319370065896666155440666101283545182816061507970246071138082866141473;
    uint256 constant IC42y = 9974888098661534076821404910086225703212771397249291023634267775961823782481;
    
    uint256 constant IC43x = 5390872632590629121004502265774799866365873296893355638683968928801752921582;
    uint256 constant IC43y = 13561932083585196006752215489899456733897198730165061056596966177905476385908;
    
    uint256 constant IC44x = 8910397434636103173893217788592584029947691415416891711514828523127054533446;
    uint256 constant IC44y = 8916829310027369826463806963919013733756487740362676057381358452900612349595;
    
    uint256 constant IC45x = 3234358538473961298871469925442101508996136282695110168430952080596812624035;
    uint256 constant IC45y = 5602749478030200087808543714480609069675668357028362443276170094757110395656;
    
    uint256 constant IC46x = 10071739703460047497007946074457566884071502137637732983781426185668032612935;
    uint256 constant IC46y = 7720964154715979601407035633830554151030807855903474383224850959656580976388;
    
    uint256 constant IC47x = 19883017688532745352722788215882725642192993835172239812147341646323732851868;
    uint256 constant IC47y = 692826041829213496498277582944736821840245670959304311273782203449001143545;
    
    uint256 constant IC48x = 6576118634537325731303176495946213396069385850561644277806258448206135801113;
    uint256 constant IC48y = 322141927650116988725641891341443338584393995729540626748621721121312002595;
    
    uint256 constant IC49x = 3477393306344872166175470502313499906705844267747244364501357436537560821570;
    uint256 constant IC49y = 11083789548027216761485080776275355768404504686266212115621025766273005467646;
    
    uint256 constant IC50x = 498068478894863082974182605476096242725143190695475331131437451345075153121;
    uint256 constant IC50y = 17536087443211613002300919138848948499511473385124613946582359836413398724343;
    
    uint256 constant IC51x = 12283690125674351737582611331919421877680426100223886252858808841820405323957;
    uint256 constant IC51y = 13699602096196347921980558788528398731502756241213493600198258767201075009163;
    
    uint256 constant IC52x = 17233457809604840678198265734345344918544904959649659367120729140940516769870;
    uint256 constant IC52y = 11445459232776321800257971189490903193022434725399287475874723399331093865163;
    
    uint256 constant IC53x = 10299254123857252427521376930971290706853238337753979804752952491259789434456;
    uint256 constant IC53y = 7694156271171175186803337462218245208771264684561249392991022548585787673398;
    
    uint256 constant IC54x = 5968913492773536196052352490050521733948552096687877713949138092168426328164;
    uint256 constant IC54y = 7573580760483937003413994206007564478242394027062267849746037954321114652486;
    
    uint256 constant IC55x = 4872125887129562260091765468430498677272932865785922704345496544853551484404;
    uint256 constant IC55y = 1385130696837880600023706246481072240947388550139485047460264950406373351960;
    
    uint256 constant IC56x = 20148576915288770439684659211142036686855898643192138458621130998485309239407;
    uint256 constant IC56y = 4433462662646950070882382111292431561381221955092046157110548990999257379382;
    
    uint256 constant IC57x = 18220753872382490900825154081726404473813650870024356544453383634021493477203;
    uint256 constant IC57y = 13398567252950960904979677793754425062080942595886275953927195231997483122628;
    
    uint256 constant IC58x = 20402155572527803578323878925466222766362991198684806095803029038497032648539;
    uint256 constant IC58y = 13965825451645794931161571069753038857317965925119505418118766515462917421319;
    
    uint256 constant IC59x = 18466325693873782414263290452172183661101855595889987399386086717600056841879;
    uint256 constant IC59y = 2531537301093383827658276964447585545309944585826391369004577967307189771407;
    
    uint256 constant IC60x = 15916087586497339643720015077080709388445987425251657174478336728261684326621;
    uint256 constant IC60y = 13645513872061509741666646855582347943945290883854700880939770644728349190544;
    
    uint256 constant IC61x = 15288769898695773341626700443575731653000180261078427618717374148017704897313;
    uint256 constant IC61y = 5343995013810218042057103481275555147029298087196594909912005054862724199126;
    
    uint256 constant IC62x = 16973155562070406927321258232261821845431574750489433350182591995637346338267;
    uint256 constant IC62y = 17339289912740676624096228454947544754523016060312900600855743843424410570611;
    
    uint256 constant IC63x = 4301364227893456726717366612387014754677318000824727155702359515610825891598;
    uint256 constant IC63y = 3312640060783795644416200824800339606972883462055842768532625408467195063034;
    
    uint256 constant IC64x = 21517390117407992606420087214699629386236788086410346792510251507617005877301;
    uint256 constant IC64y = 5570783865757095707970991188087325752503659190012296579829590611861951313466;
    
    uint256 constant IC65x = 12196624400203343604700833227000703117311833553170240018843685241109967037464;
    uint256 constant IC65y = 12318291767538650365570073980359142110337597905580156677699674874699831804029;
    
    uint256 constant IC66x = 12146429534981606763379511679019233686018717154950985757097374573132175897090;
    uint256 constant IC66y = 14077514112204846779620734326324876867106605924678920845658173564170765514494;
    
    uint256 constant IC67x = 13391437878992051905665731111525754768926304221573645717188058522219440649426;
    uint256 constant IC67y = 10432963358219161771715860114457384483451220696170818222271223649996667206885;
    
    uint256 constant IC68x = 10042541823878349143437578977927938358218267338851618859848423074850534784989;
    uint256 constant IC68y = 18084221382504448677451264682770369419329811363965798557454404036376377505471;
    
    uint256 constant IC69x = 1559552172276240855934321150128218464905398646445269694694784711214342242979;
    uint256 constant IC69y = 5327603066074972391532876531123563568389801126055388606008570628095799043742;
    
    uint256 constant IC70x = 10930876393081891879168189107584743378132523879757726427354268723875238923310;
    uint256 constant IC70y = 11324963190678649094122145506457356038644633201837116273951528936191985272139;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[70] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                
                g1_mulAccC(_pVk, IC33x, IC33y, calldataload(add(pubSignals, 1024)))
                
                g1_mulAccC(_pVk, IC34x, IC34y, calldataload(add(pubSignals, 1056)))
                
                g1_mulAccC(_pVk, IC35x, IC35y, calldataload(add(pubSignals, 1088)))
                
                g1_mulAccC(_pVk, IC36x, IC36y, calldataload(add(pubSignals, 1120)))
                
                g1_mulAccC(_pVk, IC37x, IC37y, calldataload(add(pubSignals, 1152)))
                
                g1_mulAccC(_pVk, IC38x, IC38y, calldataload(add(pubSignals, 1184)))
                
                g1_mulAccC(_pVk, IC39x, IC39y, calldataload(add(pubSignals, 1216)))
                
                g1_mulAccC(_pVk, IC40x, IC40y, calldataload(add(pubSignals, 1248)))
                
                g1_mulAccC(_pVk, IC41x, IC41y, calldataload(add(pubSignals, 1280)))
                
                g1_mulAccC(_pVk, IC42x, IC42y, calldataload(add(pubSignals, 1312)))
                
                g1_mulAccC(_pVk, IC43x, IC43y, calldataload(add(pubSignals, 1344)))
                
                g1_mulAccC(_pVk, IC44x, IC44y, calldataload(add(pubSignals, 1376)))
                
                g1_mulAccC(_pVk, IC45x, IC45y, calldataload(add(pubSignals, 1408)))
                
                g1_mulAccC(_pVk, IC46x, IC46y, calldataload(add(pubSignals, 1440)))
                
                g1_mulAccC(_pVk, IC47x, IC47y, calldataload(add(pubSignals, 1472)))
                
                g1_mulAccC(_pVk, IC48x, IC48y, calldataload(add(pubSignals, 1504)))
                
                g1_mulAccC(_pVk, IC49x, IC49y, calldataload(add(pubSignals, 1536)))
                
                g1_mulAccC(_pVk, IC50x, IC50y, calldataload(add(pubSignals, 1568)))
                
                g1_mulAccC(_pVk, IC51x, IC51y, calldataload(add(pubSignals, 1600)))
                
                g1_mulAccC(_pVk, IC52x, IC52y, calldataload(add(pubSignals, 1632)))
                
                g1_mulAccC(_pVk, IC53x, IC53y, calldataload(add(pubSignals, 1664)))
                
                g1_mulAccC(_pVk, IC54x, IC54y, calldataload(add(pubSignals, 1696)))
                
                g1_mulAccC(_pVk, IC55x, IC55y, calldataload(add(pubSignals, 1728)))
                
                g1_mulAccC(_pVk, IC56x, IC56y, calldataload(add(pubSignals, 1760)))
                
                g1_mulAccC(_pVk, IC57x, IC57y, calldataload(add(pubSignals, 1792)))
                
                g1_mulAccC(_pVk, IC58x, IC58y, calldataload(add(pubSignals, 1824)))
                
                g1_mulAccC(_pVk, IC59x, IC59y, calldataload(add(pubSignals, 1856)))
                
                g1_mulAccC(_pVk, IC60x, IC60y, calldataload(add(pubSignals, 1888)))
                
                g1_mulAccC(_pVk, IC61x, IC61y, calldataload(add(pubSignals, 1920)))
                
                g1_mulAccC(_pVk, IC62x, IC62y, calldataload(add(pubSignals, 1952)))
                
                g1_mulAccC(_pVk, IC63x, IC63y, calldataload(add(pubSignals, 1984)))
                
                g1_mulAccC(_pVk, IC64x, IC64y, calldataload(add(pubSignals, 2016)))
                
                g1_mulAccC(_pVk, IC65x, IC65y, calldataload(add(pubSignals, 2048)))
                
                g1_mulAccC(_pVk, IC66x, IC66y, calldataload(add(pubSignals, 2080)))
                
                g1_mulAccC(_pVk, IC67x, IC67y, calldataload(add(pubSignals, 2112)))
                
                g1_mulAccC(_pVk, IC68x, IC68y, calldataload(add(pubSignals, 2144)))
                
                g1_mulAccC(_pVk, IC69x, IC69y, calldataload(add(pubSignals, 2176)))
                
                g1_mulAccC(_pVk, IC70x, IC70y, calldataload(add(pubSignals, 2208)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            
            checkField(calldataload(add(_pubSignals, 1024)))
            
            checkField(calldataload(add(_pubSignals, 1056)))
            
            checkField(calldataload(add(_pubSignals, 1088)))
            
            checkField(calldataload(add(_pubSignals, 1120)))
            
            checkField(calldataload(add(_pubSignals, 1152)))
            
            checkField(calldataload(add(_pubSignals, 1184)))
            
            checkField(calldataload(add(_pubSignals, 1216)))
            
            checkField(calldataload(add(_pubSignals, 1248)))
            
            checkField(calldataload(add(_pubSignals, 1280)))
            
            checkField(calldataload(add(_pubSignals, 1312)))
            
            checkField(calldataload(add(_pubSignals, 1344)))
            
            checkField(calldataload(add(_pubSignals, 1376)))
            
            checkField(calldataload(add(_pubSignals, 1408)))
            
            checkField(calldataload(add(_pubSignals, 1440)))
            
            checkField(calldataload(add(_pubSignals, 1472)))
            
            checkField(calldataload(add(_pubSignals, 1504)))
            
            checkField(calldataload(add(_pubSignals, 1536)))
            
            checkField(calldataload(add(_pubSignals, 1568)))
            
            checkField(calldataload(add(_pubSignals, 1600)))
            
            checkField(calldataload(add(_pubSignals, 1632)))
            
            checkField(calldataload(add(_pubSignals, 1664)))
            
            checkField(calldataload(add(_pubSignals, 1696)))
            
            checkField(calldataload(add(_pubSignals, 1728)))
            
            checkField(calldataload(add(_pubSignals, 1760)))
            
            checkField(calldataload(add(_pubSignals, 1792)))
            
            checkField(calldataload(add(_pubSignals, 1824)))
            
            checkField(calldataload(add(_pubSignals, 1856)))
            
            checkField(calldataload(add(_pubSignals, 1888)))
            
            checkField(calldataload(add(_pubSignals, 1920)))
            
            checkField(calldataload(add(_pubSignals, 1952)))
            
            checkField(calldataload(add(_pubSignals, 1984)))
            
            checkField(calldataload(add(_pubSignals, 2016)))
            
            checkField(calldataload(add(_pubSignals, 2048)))
            
            checkField(calldataload(add(_pubSignals, 2080)))
            
            checkField(calldataload(add(_pubSignals, 2112)))
            
            checkField(calldataload(add(_pubSignals, 2144)))
            
            checkField(calldataload(add(_pubSignals, 2176)))
            
            checkField(calldataload(add(_pubSignals, 2208)))
            
            checkField(calldataload(add(_pubSignals, 2240)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }


// File contracts/Nft_9_20Verifier.sol

// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 10551660914220063530702982524054577051958309958624400557782040646820920736161;
    uint256 constant deltax2 = 7960788038234536566881110568512786265775041928864486123701799111771402193659;
    uint256 constant deltay1 = 5032864550571638781107800403501234550812284086756053812262397433046583274376;
    uint256 constant deltay2 = 11769772818512398690194343755109481200615139293151352221624700981223468785856;

    
    uint256 constant IC0x = 15433793690009739708391402189533562375756397528493745790704462086371550216462;
    uint256 constant IC0y = 6585346107550398307360885305430646545562149317849231016786540059576942757184;
    
    uint256 constant IC1x = 3641309113213656817909351627579557758585752818459875040508822049878714741528;
    uint256 constant IC1y = 17240543483520399768249194656754331729020274758576868327684554483192113442626;
    
    uint256 constant IC2x = 15753573327349857449160928422017305637286172539762885865747992073329496984184;
    uint256 constant IC2y = 13221533100278559055402621946286638660741717833386369438256544783774129696801;
    
    uint256 constant IC3x = 11267210970612916573492907917006569052080446703645562596418358538236919848195;
    uint256 constant IC3y = 17486224395319702484966946188040455073803502208510654360667652888109195546658;
    
    uint256 constant IC4x = 10956843263895657007528216677488704267401264475323485383949552725629559651963;
    uint256 constant IC4y = 16334436873177842872373295561785227723249009333249689039402913949151964239164;
    
    uint256 constant IC5x = 18935458880492332915563251158579545253206828962785304637335225704018811874907;
    uint256 constant IC5y = 18455087186582102753205471662713255282273193292198572010016276268491635872894;
    
    uint256 constant IC6x = 19749598297423261145497034745947184430918132929513356238608464994758789310429;
    uint256 constant IC6y = 7568954112222763837132140205439102931401688592757221293301057299450691614642;
    
    uint256 constant IC7x = 19845223918944681308003930158327896855285893361954388768451572599294593238497;
    uint256 constant IC7y = 5319863672230837783983011880988059171172581016284169979692725407421122629957;
    
    uint256 constant IC8x = 16213992362858854191124698556697051880065239214063906801236663494275566456624;
    uint256 constant IC8y = 10189400473158371793070808395835377000931477436331449366211526194172061257049;
    
    uint256 constant IC9x = 10546523440024870011670911979944222198817783387608694567400565099334111742908;
    uint256 constant IC9y = 18160175464263865084464351079811515901836866521046357246524906152119968670930;
    
    uint256 constant IC10x = 10563822013234690277161694304590384544717556201564697056498360543097647415352;
    uint256 constant IC10y = 8370115329280824553767776598096432067498957091523673846705865644489199633198;
    
    uint256 constant IC11x = 21113937973934345726726515161443376287692724713103206050888033130234099096595;
    uint256 constant IC11y = 2120576873931000899031485719936040652777137213664275841366371784881670437239;
    
    uint256 constant IC12x = 19140201761109883194111824165500436757689918090958241845216691255369305550759;
    uint256 constant IC12y = 13514342896098839573365431037015689192760280445558361994054973195519753554080;
    
    uint256 constant IC13x = 10930544251793512600127898266053149988873149011806672826985896751000625893260;
    uint256 constant IC13y = 7468796700093256314390315155650373095424841410222581742890529564806267608466;
    
    uint256 constant IC14x = 9836786759964120956619625952545287804735087935054923360131647255785510021335;
    uint256 constant IC14y = 16801970823377548554937963474860151568965497316698386294002445770806987719223;
    
    uint256 constant IC15x = 2679415408324775066696264153847074646345199526960966344198101758271555592846;
    uint256 constant IC15y = 14537045281768523227459460826746619337396910374373136811303780738367982710052;
    
    uint256 constant IC16x = 8074674216703617627756050149034901913444695306025925333886151668358469995192;
    uint256 constant IC16y = 15571677727151104242340313159129825859776825171985125702543156776981763545017;
    
    uint256 constant IC17x = 7130580157238072378292602878389753011371436687762012758485642843838373826333;
    uint256 constant IC17y = 13362233867712911223710341886233841444566672846019616141188512258292976581437;
    
    uint256 constant IC18x = 15764195115094311423237830363201726486206550235744710575213662834548033003755;
    uint256 constant IC18y = 16275397471152238105584735040174923508766825212094412988115915182450658873002;
    
    uint256 constant IC19x = 18459552881299245232950043572870969001510054332796192318293786825580312394419;
    uint256 constant IC19y = 13748023477821779638760005331214371493365312795810888627503076910244947668699;
    
    uint256 constant IC20x = 21404596087710050649806568761075728709828945319934283856701844330699136905705;
    uint256 constant IC20y = 7993618403821484731537566095100299553063652208451092896416155171761533092559;
    
    uint256 constant IC21x = 9179567663329735571512382110026875540208618265791828366652772561122424603595;
    uint256 constant IC21y = 18097292851521858978114013854236516259252590604872966656075709723312552290890;
    
    uint256 constant IC22x = 11176179374281231922225327235415691548755458699034304917372619826658382181232;
    uint256 constant IC22y = 21221069892598429559590998334667528550946105368100720267833495717144915755842;
    
    uint256 constant IC23x = 21007242853032551507609784629584930148755863614549698425184957823848713672252;
    uint256 constant IC23y = 12857710468855113615884773322381558092786193332432563146888355905348955683998;
    
    uint256 constant IC24x = 423113729990669368284269253118044415239070596622629813957742243997738642299;
    uint256 constant IC24y = 1563706947814447830259414941982502406616068886041118255250465182921243924472;
    
    uint256 constant IC25x = 9748057477739407388795483427704096509091967434966815707238342460425176880461;
    uint256 constant IC25y = 17572504598690474440387831859420649032195409080972099056792048533388187673693;
    
    uint256 constant IC26x = 15128229456215032404372907123962629226694813059789212291704961032988905488083;
    uint256 constant IC26y = 16051086973498193318793154519419540403088168964676821819348976100048308306013;
    
    uint256 constant IC27x = 20377226172994256219640618250252342910440745851181738317257981772025211517233;
    uint256 constant IC27y = 20474307019630634850422020450915429294256151692024111684233120158884250853257;
    
    uint256 constant IC28x = 4970775774776423671163521418254645045729844280752035249226208193669960811377;
    uint256 constant IC28y = 6379114737165240272428020358215073932579061818293590092343848316086123393254;
    
    uint256 constant IC29x = 16180929253184179275835234177115731007783324631127859378340716001684162496258;
    uint256 constant IC29y = 9366643836865919813775940127135164865476206550461228050471675146116299276332;
    
    uint256 constant IC30x = 17055769728757484481573866446510988340764108167831555126870303634841371509186;
    uint256 constant IC30y = 10177941598784572940450054736137593631030768856972171509577368470596273251310;
    
    uint256 constant IC31x = 5410684372981526066040772515467212419400406998719670696534188320620914172796;
    uint256 constant IC31y = 8686816594419414180103069001112608637705067440409622086891545266672857124408;
    
    uint256 constant IC32x = 17074455881387661593333902634868959752079584172001807147610898427890481212741;
    uint256 constant IC32y = 20123869434785834449104903129507238013274757741982902372627570995673374511562;
    
    uint256 constant IC33x = 4564432711294628222766464799396250843160895273560800371668649727691842238929;
    uint256 constant IC33y = 10153225282917246408379046402876638299933846599286557133169378661863023646067;
    
    uint256 constant IC34x = 14690553601202693949041608059552287826282139458260499658441072125068536297846;
    uint256 constant IC34y = 14109256153711002383456766102233918788295113497225422827976462865297437218616;
    
    uint256 constant IC35x = 101285833698379455619658751598806316941907426884102844347255941965114512937;
    uint256 constant IC35y = 21196232586722886207216579712753330001240215037948546218763158972200631435420;
    
    uint256 constant IC36x = 21481028178537615027156368431334469767033885757631557259349491527521039798980;
    uint256 constant IC36y = 677380606590927592693247406382076870193812253940801244046431644165580792711;
    
    uint256 constant IC37x = 15833391679100808317770416945842094451298967974088951644906997851800897197702;
    uint256 constant IC37y = 11143302686095222631988544618137727668751470984625555505848473752920706108125;
    
    uint256 constant IC38x = 10970364082843425016004038108589016381369566098689878050130756554555538628701;
    uint256 constant IC38y = 12533209791829821942963144549506340680815730764592259849850092269095965031808;
    
    uint256 constant IC39x = 6796916078439583108486555528689895878112112359058670561190891352913357626042;
    uint256 constant IC39y = 20920872657511633622096848289226705282154033677190339738609775351114430763992;
    
    uint256 constant IC40x = 9826221579022281758723357861212519292699154662502903713003643219820138937140;
    uint256 constant IC40y = 17626148833645653648329935839328914354044525189443944110765572894721944538980;
    
    uint256 constant IC41x = 14559141165904203409429076325029244897566067453145223238202435520935248746182;
    uint256 constant IC41y = 4101897576326176749075830354588291732889854527981478252142887564129474218883;
    
    uint256 constant IC42x = 570805636087267463248206518501508560968725760697360180667162520210038095435;
    uint256 constant IC42y = 7035289675866867042905055232127030179262631773111472654314024983072635772704;
    
    uint256 constant IC43x = 6122787727006720358408040802599513276656777881471446801846625951518697135779;
    uint256 constant IC43y = 17535432550255366880765596700351353844321599106340175523194462440130305200355;
    
    uint256 constant IC44x = 18917920653542963733473878448488418702516803442912288486212699846809674235282;
    uint256 constant IC44y = 18269494663165142075591990094981325069465619890978537104977246608381051673664;
    
    uint256 constant IC45x = 14015795210457835431228312146730028422597926430669602299093338763971524733831;
    uint256 constant IC45y = 4481572660336873270419386111581443949040850843570490440793084517212630512599;
    
    uint256 constant IC46x = 18743799481611010891297742628534756768560180926200391472837348550074154921118;
    uint256 constant IC46y = 180425513077462803086246338097564162129468422623411699063934356596233134721;
    
    uint256 constant IC47x = 3133814358178221823940564934357758254886368612307573998119018613182203208459;
    uint256 constant IC47y = 18992241079195214864852352556855626128816490077714787488515219142528578691961;
    
    uint256 constant IC48x = 13547887302366742400708909277248282793271153921182236618704860408816272785645;
    uint256 constant IC48y = 21874467190273400942737341076523926256367243254420657256335069300025271059504;
    
    uint256 constant IC49x = 10322413770382966606302788301448311892016985646761253515921805087966524059552;
    uint256 constant IC49y = 5591824840822869108887810686507905576979402379933217153481088630495028790876;
    
    uint256 constant IC50x = 6117600554152793048245031373957654435095339170624049677044363851847423533736;
    uint256 constant IC50y = 19146919427417457499113515594574007127469088479237103341421840422225491418270;
    
    uint256 constant IC51x = 17511330192012816207504712106390980111566699264295162599503062003930867903593;
    uint256 constant IC51y = 19395213126487571770692911700280957591329432432873873101842905774270990815617;
    
    uint256 constant IC52x = 5226262657418761802906383300774193807517396216456548070641134031290747173483;
    uint256 constant IC52y = 15848082951527712915582692858700769081059749545427127340219258224013272066499;
    
    uint256 constant IC53x = 14506230251071617701469459818397505334275257624076416527680390776487084784704;
    uint256 constant IC53y = 3645409843023715060190007629289496925478511551446377242439773804071258541450;
    
    uint256 constant IC54x = 13638594685750147693289263217929114309484927572113750775944984607446372475405;
    uint256 constant IC54y = 1152326003034070050816920702999600864266212820734527969119618009052851574875;
    
    uint256 constant IC55x = 4742566594952042497149069467808538355558178414911901162924369677220301149666;
    uint256 constant IC55y = 13234031440457045133973502499166180300575978161126685757201368582305279699147;
    
    uint256 constant IC56x = 6416037695523466280172445677603035150457811511160265907869426616399555157925;
    uint256 constant IC56y = 11763988828250536291967767692513910048024529312736738178623749921957264300695;
    
    uint256 constant IC57x = 11658026697607468444027556941061469822661645506863385871871904546996615474511;
    uint256 constant IC57y = 12777454350305000994611392692401914976574591359990152304040594478914225590106;
    
    uint256 constant IC58x = 21508312009771589277287829214349848402562736250512430258085166702637079667056;
    uint256 constant IC58y = 10124526283420557768725628117886155217413674767907864440706385958535108623491;
    
    uint256 constant IC59x = 14338553220440540134779634145177991866128797826651431937882512228409239694833;
    uint256 constant IC59y = 8821080267555608101093520823485622475266703024025637275157060116869145888724;
    
    uint256 constant IC60x = 20079297008644192050185841592908733820143892490544429535935719258869687029965;
    uint256 constant IC60y = 12476743520368101425349540399284823098700254798002549379382841904133968846218;
    
    uint256 constant IC61x = 2798745133789484413015459308938972858345422504528860688382217637403308954126;
    uint256 constant IC61y = 21641114244763925681536561103102683543040357035102959110969542494033578772154;
    
    uint256 constant IC62x = 12822798705621142464023821907455875974435416095006802848324945962777141250852;
    uint256 constant IC62y = 7430013540967850995118538231268054005202847822283840785339754510728795749764;
    
    uint256 constant IC63x = 15519840594893102444301163880953585001358331427689639414968609777248082596228;
    uint256 constant IC63y = 7046809733633465425304294094940932208565185819849301616708367875328133444882;
    
    uint256 constant IC64x = 14526801900305401515483381020060534672464719343368175952168729193506817278709;
    uint256 constant IC64y = 18063519024794125809400031544570298978368857621543371076329609347042035194756;
    
    uint256 constant IC65x = 19698617965020394370556952775492677049340727642127768378785313253780062878008;
    uint256 constant IC65y = 13246334509838098270770763858095596131898230862866648043661247137464557858262;
    
    uint256 constant IC66x = 3274985866093868275963172913756818175404587876002979268487504159941846311123;
    uint256 constant IC66y = 4590425884542995161934392844719573986950141099066438285513072215012292703577;
    
    uint256 constant IC67x = 16887927602788033991071174013446220732984707621128845148012490820704680605851;
    uint256 constant IC67y = 12400233807211457257002479744664608267495491069721553007675512299359934244414;
    
    uint256 constant IC68x = 17352694083421587516196884737892816019544449784387627191456473384847187794852;
    uint256 constant IC68y = 1393865315097426303776787528282796975746509786780725827056247593982587540361;
    
    uint256 constant IC69x = 14890620635543838498025218055403697230162226640121822521262519060307167330690;
    uint256 constant IC69y = 4806178971551111975284175240670205179910905351374821699805892151720453998494;
    
    uint256 constant IC70x = 11162863378316370422335325994769158400007369054709675013551229839013896058751;
    uint256 constant IC70y = 17477193694459056727522800273847098145497444481749478518941024423378769926187;
    
    uint256 constant IC71x = 4887751730851382543279367086922372516219283495901991246100229439932457950689;
    uint256 constant IC71y = 15393911354011225751112052351593863194947006235418245167269085185560858195836;
    
    uint256 constant IC72x = 11784604078921622425593425753565819300440022786962897893973724654765971090089;
    uint256 constant IC72y = 2514365213079654443640315675406192252344086218992657495529406305936300337214;
    
    uint256 constant IC73x = 14072840061882452369032927352444025821822824376534605796825108630679318541742;
    uint256 constant IC73y = 12453001862973929351299357019068569775174900595169602226936924287053101038663;
    
    uint256 constant IC74x = 16942326107358243649179181131490589695816205226980645868904097432399788751950;
    uint256 constant IC74y = 8557758433335019636120329844873519300318921986064229028428119980700174779092;
    
    uint256 constant IC75x = 19451250338802582060130399813484082491989017321343141616378935231031155434981;
    uint256 constant IC75y = 9905298729441257156396398247660055626844463261796242440015547266467307688469;
    
    uint256 constant IC76x = 21311904198043582168831446284682052164979443536891796693817530866016934354467;
    uint256 constant IC76y = 7534713892599903574356450389458490301903862628212519134859234702822784166442;
    
    uint256 constant IC77x = 4633420971352812701849574830523662910110120617899430521697476080796227683247;
    uint256 constant IC77y = 3749775826519846648968842748330041358094670119611489216031928856554728288724;
    
    uint256 constant IC78x = 9366924247335840919258959081409503793379511309858332510336622665287480012567;
    uint256 constant IC78y = 17132639049021794231835991085205685721368566949224358573137394252005910871854;
    
    uint256 constant IC79x = 18074904182401874318263286955666067276403382214101024553665030348288263732091;
    uint256 constant IC79y = 17789875058412898516508283864609212371608144973952437783125280175482661224304;
    
    uint256 constant IC80x = 2303556448392982431206256370677502791310208671330879330931890780938904017954;
    uint256 constant IC80y = 3523456849886580822574178939984625345280373030562024697388072355185602828305;
    
    uint256 constant IC81x = 5959007867474778519532810082957781608359190214725254158291921395602310471789;
    uint256 constant IC81y = 9658041055296638660873707622585628639603328914782615492485663157787200453961;
    
    uint256 constant IC82x = 1070027833505056256564054846193061261088564765943796672543366894514861083233;
    uint256 constant IC82y = 11588364433638494759750664334294907980779719010896912535131703291531227156066;
    
    uint256 constant IC83x = 19056623400570867048810435293927183551356329703515925107044764129202212609697;
    uint256 constant IC83y = 19657701771595891635530857447894963005749418764450338608542379877886294669464;
    
    uint256 constant IC84x = 10923050279675729352313318163620851827777726109061092463047538828830037009444;
    uint256 constant IC84y = 5663956969609050835264301418572559351575301187246243414234551217529916164582;
    
    uint256 constant IC85x = 16382180356785971704373875745810073132183398466903506821292944831718992578631;
    uint256 constant IC85y = 4292850385046580500591103455496506403772420724272891277560320686793807264888;
    
    uint256 constant IC86x = 2740617634479435445870771920293045207011581637707776884403249833340389418771;
    uint256 constant IC86y = 8663994931547175017607446898473172937655010792522029273085233157579068328605;
    
    uint256 constant IC87x = 2930028068727351276331718969829895096669070738627735707708593644227769568738;
    uint256 constant IC87y = 1553889882210665155577688924418792483702577818121964166652962399188582540817;
    
    uint256 constant IC88x = 10051936001551591646695160813410203930881611525458581980922337877260831742622;
    uint256 constant IC88y = 21864494484447722543572370496732090234923361031824367069441444369416916603531;
    
    uint256 constant IC89x = 17313339065117724923069023021546794869719901609023524067307126663111008920165;
    uint256 constant IC89y = 21702996617625750962285895077594865895587698055125383105762396825553977243164;
    
    uint256 constant IC90x = 6669522541589606504411367244889046894142986997469179239326134924020124868292;
    uint256 constant IC90y = 7441377658907782056240945037078550379137564244570224728569681535241669627069;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[90] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                
                g1_mulAccC(_pVk, IC33x, IC33y, calldataload(add(pubSignals, 1024)))
                
                g1_mulAccC(_pVk, IC34x, IC34y, calldataload(add(pubSignals, 1056)))
                
                g1_mulAccC(_pVk, IC35x, IC35y, calldataload(add(pubSignals, 1088)))
                
                g1_mulAccC(_pVk, IC36x, IC36y, calldataload(add(pubSignals, 1120)))
                
                g1_mulAccC(_pVk, IC37x, IC37y, calldataload(add(pubSignals, 1152)))
                
                g1_mulAccC(_pVk, IC38x, IC38y, calldataload(add(pubSignals, 1184)))
                
                g1_mulAccC(_pVk, IC39x, IC39y, calldataload(add(pubSignals, 1216)))
                
                g1_mulAccC(_pVk, IC40x, IC40y, calldataload(add(pubSignals, 1248)))
                
                g1_mulAccC(_pVk, IC41x, IC41y, calldataload(add(pubSignals, 1280)))
                
                g1_mulAccC(_pVk, IC42x, IC42y, calldataload(add(pubSignals, 1312)))
                
                g1_mulAccC(_pVk, IC43x, IC43y, calldataload(add(pubSignals, 1344)))
                
                g1_mulAccC(_pVk, IC44x, IC44y, calldataload(add(pubSignals, 1376)))
                
                g1_mulAccC(_pVk, IC45x, IC45y, calldataload(add(pubSignals, 1408)))
                
                g1_mulAccC(_pVk, IC46x, IC46y, calldataload(add(pubSignals, 1440)))
                
                g1_mulAccC(_pVk, IC47x, IC47y, calldataload(add(pubSignals, 1472)))
                
                g1_mulAccC(_pVk, IC48x, IC48y, calldataload(add(pubSignals, 1504)))
                
                g1_mulAccC(_pVk, IC49x, IC49y, calldataload(add(pubSignals, 1536)))
                
                g1_mulAccC(_pVk, IC50x, IC50y, calldataload(add(pubSignals, 1568)))
                
                g1_mulAccC(_pVk, IC51x, IC51y, calldataload(add(pubSignals, 1600)))
                
                g1_mulAccC(_pVk, IC52x, IC52y, calldataload(add(pubSignals, 1632)))
                
                g1_mulAccC(_pVk, IC53x, IC53y, calldataload(add(pubSignals, 1664)))
                
                g1_mulAccC(_pVk, IC54x, IC54y, calldataload(add(pubSignals, 1696)))
                
                g1_mulAccC(_pVk, IC55x, IC55y, calldataload(add(pubSignals, 1728)))
                
                g1_mulAccC(_pVk, IC56x, IC56y, calldataload(add(pubSignals, 1760)))
                
                g1_mulAccC(_pVk, IC57x, IC57y, calldataload(add(pubSignals, 1792)))
                
                g1_mulAccC(_pVk, IC58x, IC58y, calldataload(add(pubSignals, 1824)))
                
                g1_mulAccC(_pVk, IC59x, IC59y, calldataload(add(pubSignals, 1856)))
                
                g1_mulAccC(_pVk, IC60x, IC60y, calldataload(add(pubSignals, 1888)))
                
                g1_mulAccC(_pVk, IC61x, IC61y, calldataload(add(pubSignals, 1920)))
                
                g1_mulAccC(_pVk, IC62x, IC62y, calldataload(add(pubSignals, 1952)))
                
                g1_mulAccC(_pVk, IC63x, IC63y, calldataload(add(pubSignals, 1984)))
                
                g1_mulAccC(_pVk, IC64x, IC64y, calldataload(add(pubSignals, 2016)))
                
                g1_mulAccC(_pVk, IC65x, IC65y, calldataload(add(pubSignals, 2048)))
                
                g1_mulAccC(_pVk, IC66x, IC66y, calldataload(add(pubSignals, 2080)))
                
                g1_mulAccC(_pVk, IC67x, IC67y, calldataload(add(pubSignals, 2112)))
                
                g1_mulAccC(_pVk, IC68x, IC68y, calldataload(add(pubSignals, 2144)))
                
                g1_mulAccC(_pVk, IC69x, IC69y, calldataload(add(pubSignals, 2176)))
                
                g1_mulAccC(_pVk, IC70x, IC70y, calldataload(add(pubSignals, 2208)))
                
                g1_mulAccC(_pVk, IC71x, IC71y, calldataload(add(pubSignals, 2240)))
                
                g1_mulAccC(_pVk, IC72x, IC72y, calldataload(add(pubSignals, 2272)))
                
                g1_mulAccC(_pVk, IC73x, IC73y, calldataload(add(pubSignals, 2304)))
                
                g1_mulAccC(_pVk, IC74x, IC74y, calldataload(add(pubSignals, 2336)))
                
                g1_mulAccC(_pVk, IC75x, IC75y, calldataload(add(pubSignals, 2368)))
                
                g1_mulAccC(_pVk, IC76x, IC76y, calldataload(add(pubSignals, 2400)))
                
                g1_mulAccC(_pVk, IC77x, IC77y, calldataload(add(pubSignals, 2432)))
                
                g1_mulAccC(_pVk, IC78x, IC78y, calldataload(add(pubSignals, 2464)))
                
                g1_mulAccC(_pVk, IC79x, IC79y, calldataload(add(pubSignals, 2496)))
                
                g1_mulAccC(_pVk, IC80x, IC80y, calldataload(add(pubSignals, 2528)))
                
                g1_mulAccC(_pVk, IC81x, IC81y, calldataload(add(pubSignals, 2560)))
                
                g1_mulAccC(_pVk, IC82x, IC82y, calldataload(add(pubSignals, 2592)))
                
                g1_mulAccC(_pVk, IC83x, IC83y, calldataload(add(pubSignals, 2624)))
                
                g1_mulAccC(_pVk, IC84x, IC84y, calldataload(add(pubSignals, 2656)))
                
                g1_mulAccC(_pVk, IC85x, IC85y, calldataload(add(pubSignals, 2688)))
                
                g1_mulAccC(_pVk, IC86x, IC86y, calldataload(add(pubSignals, 2720)))
                
                g1_mulAccC(_pVk, IC87x, IC87y, calldataload(add(pubSignals, 2752)))
                
                g1_mulAccC(_pVk, IC88x, IC88y, calldataload(add(pubSignals, 2784)))
                
                g1_mulAccC(_pVk, IC89x, IC89y, calldataload(add(pubSignals, 2816)))
                
                g1_mulAccC(_pVk, IC90x, IC90y, calldataload(add(pubSignals, 2848)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            
            checkField(calldataload(add(_pubSignals, 1024)))
            
            checkField(calldataload(add(_pubSignals, 1056)))
            
            checkField(calldataload(add(_pubSignals, 1088)))
            
            checkField(calldataload(add(_pubSignals, 1120)))
            
            checkField(calldataload(add(_pubSignals, 1152)))
            
            checkField(calldataload(add(_pubSignals, 1184)))
            
            checkField(calldataload(add(_pubSignals, 1216)))
            
            checkField(calldataload(add(_pubSignals, 1248)))
            
            checkField(calldataload(add(_pubSignals, 1280)))
            
            checkField(calldataload(add(_pubSignals, 1312)))
            
            checkField(calldataload(add(_pubSignals, 1344)))
            
            checkField(calldataload(add(_pubSignals, 1376)))
            
            checkField(calldataload(add(_pubSignals, 1408)))
            
            checkField(calldataload(add(_pubSignals, 1440)))
            
            checkField(calldataload(add(_pubSignals, 1472)))
            
            checkField(calldataload(add(_pubSignals, 1504)))
            
            checkField(calldataload(add(_pubSignals, 1536)))
            
            checkField(calldataload(add(_pubSignals, 1568)))
            
            checkField(calldataload(add(_pubSignals, 1600)))
            
            checkField(calldataload(add(_pubSignals, 1632)))
            
            checkField(calldataload(add(_pubSignals, 1664)))
            
            checkField(calldataload(add(_pubSignals, 1696)))
            
            checkField(calldataload(add(_pubSignals, 1728)))
            
            checkField(calldataload(add(_pubSignals, 1760)))
            
            checkField(calldataload(add(_pubSignals, 1792)))
            
            checkField(calldataload(add(_pubSignals, 1824)))
            
            checkField(calldataload(add(_pubSignals, 1856)))
            
            checkField(calldataload(add(_pubSignals, 1888)))
            
            checkField(calldataload(add(_pubSignals, 1920)))
            
            checkField(calldataload(add(_pubSignals, 1952)))
            
            checkField(calldataload(add(_pubSignals, 1984)))
            
            checkField(calldataload(add(_pubSignals, 2016)))
            
            checkField(calldataload(add(_pubSignals, 2048)))
            
            checkField(calldataload(add(_pubSignals, 2080)))
            
            checkField(calldataload(add(_pubSignals, 2112)))
            
            checkField(calldataload(add(_pubSignals, 2144)))
            
            checkField(calldataload(add(_pubSignals, 2176)))
            
            checkField(calldataload(add(_pubSignals, 2208)))
            
            checkField(calldataload(add(_pubSignals, 2240)))
            
            checkField(calldataload(add(_pubSignals, 2272)))
            
            checkField(calldataload(add(_pubSignals, 2304)))
            
            checkField(calldataload(add(_pubSignals, 2336)))
            
            checkField(calldataload(add(_pubSignals, 2368)))
            
            checkField(calldataload(add(_pubSignals, 2400)))
            
            checkField(calldataload(add(_pubSignals, 2432)))
            
            checkField(calldataload(add(_pubSignals, 2464)))
            
            checkField(calldataload(add(_pubSignals, 2496)))
            
            checkField(calldataload(add(_pubSignals, 2528)))
            
            checkField(calldataload(add(_pubSignals, 2560)))
            
            checkField(calldataload(add(_pubSignals, 2592)))
            
            checkField(calldataload(add(_pubSignals, 2624)))
            
            checkField(calldataload(add(_pubSignals, 2656)))
            
            checkField(calldataload(add(_pubSignals, 2688)))
            
            checkField(calldataload(add(_pubSignals, 2720)))
            
            checkField(calldataload(add(_pubSignals, 2752)))
            
            checkField(calldataload(add(_pubSignals, 2784)))
            
            checkField(calldataload(add(_pubSignals, 2816)))
            
            checkField(calldataload(add(_pubSignals, 2848)))
            
            checkField(calldataload(add(_pubSignals, 2880)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }


// File @openzeppelin/contracts/utils/Context.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File @openzeppelin/contracts/access/Ownable.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby disabling any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File @openzeppelin/contracts/utils/Address.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     *
     * Furthermore, `isContract` will also return true if the target contract within
     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
     * which only has an effect at the end of a transaction.
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File @openzeppelin/contracts/utils/math/Math.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                // Solidity will revert if denominator == 0, unlike the div opcode on its own.
                // The surrounding unchecked block does not change this fact.
                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1, "Math: mulDiv overflow");

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = sqrt(a);
            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log2(value);
            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10 ** 64) {
                value /= 10 ** 64;
                result += 64;
            }
            if (value >= 10 ** 32) {
                value /= 10 ** 32;
                result += 32;
            }
            if (value >= 10 ** 16) {
                value /= 10 ** 16;
                result += 16;
            }
            if (value >= 10 ** 8) {
                value /= 10 ** 8;
                result += 8;
            }
            if (value >= 10 ** 4) {
                value /= 10 ** 4;
                result += 4;
            }
            if (value >= 10 ** 2) {
                value /= 10 ** 2;
                result += 2;
            }
            if (value >= 10 ** 1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log10(value);
            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256, rounded down, of a positive value.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log256(value);
            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
        }
    }
}


// File @openzeppelin/contracts/utils/math/SignedMath.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard signed math utilities missing in the Solidity language.
 */
library SignedMath {
    /**
     * @dev Returns the largest of two signed numbers.
     */
    function max(int256 a, int256 b) internal pure returns (int256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two signed numbers.
     */
    function min(int256 a, int256 b) internal pure returns (int256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two signed numbers without overflow.
     * The result is rounded towards zero.
     */
    function average(int256 a, int256 b) internal pure returns (int256) {
        // Formula from the book "Hacker's Delight"
        int256 x = (a & b) + ((a ^ b) >> 1);
        return x + (int256(uint256(x) >> 255) & (a ^ b));
    }

    /**
     * @dev Returns the absolute unsigned value of a signed value.
     */
    function abs(int256 n) internal pure returns (uint256) {
        unchecked {
            // must be unchecked in order to support `n = type(int256).min`
            return uint256(n >= 0 ? n : -n);
        }
    }
}


// File @openzeppelin/contracts/utils/Strings.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)

pragma solidity ^0.8.0;


/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `int256` to its ASCII `string` decimal representation.
     */
    function toString(int256 value) internal pure returns (string memory) {
        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }

    /**
     * @dev Returns true if the two strings are equal.
     */
    function equal(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(bytes(a)) == keccak256(bytes(b));
    }
}


// File @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}


// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}


// File @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)

pragma solidity ^0.8.0;

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}


// File @openzeppelin/contracts/token/ERC721/ERC721.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)

pragma solidity ^0.8.0;







/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension, but not including the Enumerable extension, which is available separately as
 * {ERC721Enumerable}.
 */
contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to owner address
    mapping(uint256 => address) private _owners;

    // Mapping owner address to token count
    mapping(address => uint256) private _balances;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    /**
     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: address zero is not a valid owner");
        return _balances[owner];
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _ownerOf(tokenId);
        require(owner != address(0), "ERC721: invalid token ID");
        return owner;
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        _requireMinted(tokenId);

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overridden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721: approve caller is not token owner or approved for all"
        );

        _approve(to, tokenId);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        _requireMinted(tokenId);

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");

        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
        _safeTransfer(from, to, tokenId, data);
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * `data` is additional data, it has no specified format and it is sent in call to `to`.
     *
     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
     * implement alternative mechanisms to perform token transfer, such as signature-based.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
     */
    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
        return _owners[tokenId];
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     * and stop existing when they are burned (`_burn`).
     */
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
    }

    /**
     * @dev Safely mints `tokenId` and transfers it to `to`.
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, "");
    }

    /**
     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, data),
            "ERC721: transfer to non ERC721Receiver implementer"
        );
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId, 1);

        // Check that tokenId was not minted by `_beforeTokenTransfer` hook
        require(!_exists(tokenId), "ERC721: token already minted");

        unchecked {
            // Will not overflow unless all 2**256 token ids are minted to the same owner.
            // Given that tokens are minted one by one, it is impossible in practice that
            // this ever happens. Might change if we allow batch minting.
            // The ERC fails to describe this case.
            _balances[to] += 1;
        }

        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);

        _afterTokenTransfer(address(0), to, tokenId, 1);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     * This is an internal function that does not check if the sender is authorized to operate on the token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId, 1);

        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook
        owner = ERC721.ownerOf(tokenId);

        // Clear approvals
        delete _tokenApprovals[tokenId];

        unchecked {
            // Cannot overflow, as that would require more tokens to be burned/transferred
            // out than the owner initially received through minting and transferring in.
            _balances[owner] -= 1;
        }
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);

        _afterTokenTransfer(owner, address(0), tokenId, 1);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId, 1);

        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook
        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");

        // Clear approvals from the previous owner
        delete _tokenApprovals[tokenId];

        unchecked {
            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:
            // `from`'s balance is the number of token held, which is at least one before the current
            // transfer.
            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require
            // all 2**256 token ids to be minted, which in practice is impossible.
            _balances[from] -= 1;
            _balances[to] += 1;
        }
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId, 1);
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits an {Approval} event.
     */
    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    /**
     * @dev Approve `operator` to operate on all of `owner` tokens
     *
     * Emits an {ApprovalForAll} event.
     */
    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
        require(owner != operator, "ERC721: approve to caller");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @dev Reverts if the `tokenId` has not been minted yet.
     */
    function _requireMinted(uint256 tokenId) internal view virtual {
        require(_exists(tokenId), "ERC721: invalid token ID");
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
     * The call is not executed if the target address is not a contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer");
                } else {
                    /// @solidity memory-safe-assembly
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
     * - When `from` is zero, the tokens will be minted for `to`.
     * - When `to` is zero, ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     * - `batchSize` is non-zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}

    /**
     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
     * - When `from` is zero, the tokens were minted for `to`.
     * - When `to` is zero, ``from``'s tokens were burned.
     * - `from` and `to` are never both zero.
     * - `batchSize` is non-zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}

    /**
     * @dev Unsafe write access to the balances, used by extensions that "mint" tokens using an {ownerOf} override.
     *
     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant
     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such
     * that `ownerOf(tokenId)` is `a`.
     */
    // solhint-disable-next-line func-name-mixedcase
    function __unsafe_increaseBalance(address account, uint256 amount) internal {
        _balances[account] += amount;
    }
}


// File contracts/Bodies.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


// import "./Tocks.sol";

// import "./Problems.sol";

// import "hardhat/console.sol";

contract Bodies is ERC721, Ownable {
    address payable public problems;
    address public tocks;
    // bodyId to seed
    mapping(uint256 => bytes32) public seeds;
    // bodyId to styleId
    mapping(uint256 => uint256) public styles;
    uint256 public counter;
    uint256 public constant decimals = 10 ** 18;
    uint256[10] public tockPrice = [
        0, // 1st body
        0, // 2nd body
        0, // 3rd body
        1_000, // 4th body
        5_000, // 5th body
        25_000, // 6th body
        125_000, // 7th body
        625_000, // 8th body
        3_125_000, //9th body
        15_625_000 // 10th body
    ];
    // problemId to tockPrice index
    mapping(uint256 => uint256) public problemPriceLevels;

    modifier onlyProblems() {
        require(msg.sender == problems, "Only Problems can call");
        _;
    }

    event Upgrade(
        uint256 indexed persistBodyId,
        uint256 indexed burnBodyId,
        uint256 indexed styleId
    );

    constructor(address payable problems_) ERC721("Bodies", "BOD") {
        updateProblemsAddress(problems_);
    }

    fallback() external {
        revert("no fallback function");
    }

    // TODO: add metadata

    function updateTockPrice(uint256 index, uint256 price) public onlyOwner {
        require(index < 10, "Invalid index");
        tockPrice[index] = price;
    }

    function updateProblemsAddress(address payable problems_) public onlyOwner {
        problems = problems_;
    }

    function updateTocksAddress(address tocks_) public onlyOwner {
        tocks = tocks_;
    }

    function generateSeed(uint256 tokenId) public view returns (bytes32) {
        // TODO: add back blockhash
        return keccak256(abi.encodePacked(tokenId)); //blockhash(block.number - 1)));
    }

    function processPayment(address from, uint256 problemId) internal {
        uint256 problemPriceLevel = problemPriceLevels[problemId];
        require(problemPriceLevel < 10, "Problem already minted 10 bodies");
        uint256 problemPrice = tockPrice[problemPriceLevel] * decimals;
        problemPriceLevels[problemId]++;
        Tocks(tocks).burn(from, problemPrice);
    }

    function mint(uint256 problemId) public {
        require(
            Problems(problems).ownerOf(problemId) == msg.sender,
            "Not problem owner"
        );
        processPayment(msg.sender, problemId);
        counter++;
        seeds[counter] = generateSeed(counter);
        _mint(msg.sender, counter);
    }

    function mintAndBurn(
        address owner,
        uint256 problemId
    ) public onlyProblems returns (uint256) {
        // NOTE: Problems already confirms this token exists and is owned by the owner
        processPayment(owner, problemId);
        counter++;
        seeds[counter] = generateSeed(counter);
        emit Transfer(address(0), owner, counter);
        emit Transfer(owner, address(0), counter);
        return counter;
    }

    function upgrade(uint256 persistBodyId, uint256 burnBodyId) public {
        require(ownerOf(persistBodyId) == msg.sender, "Not persistBody owner");
        require(ownerOf(burnBodyId) == msg.sender, "Not burnBody owner");
        require(persistBodyId != burnBodyId, "Same body");
        require(
            styles[persistBodyId] == styles[burnBodyId],
            "Different styles"
        );
        _burn(burnBodyId);
        styles[persistBodyId]++;
        emit Upgrade(persistBodyId, burnBodyId, styles[persistBodyId]);
    }

    function burn(uint256 bodyID) public onlyProblems {
        _burn(bodyID);
    }

    function problemMint(address owner, uint256 bodyId) public onlyProblems {
        _mint(owner, bodyId);
    }
}


// File hardhat/console.sol@v2.12.2

// SPDX-License-Identifier: MIT
pragma solidity >= 0.4.22 <0.9.0;

library console {
	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

	function _sendLogPayload(bytes memory payload) private view {
		uint256 payloadLength = payload.length;
		address consoleAddress = CONSOLE_ADDRESS;
		assembly {
			let payloadStart := add(payload, 32)
			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
		}
	}

	function log() internal view {
		_sendLogPayload(abi.encodeWithSignature("log()"));
	}

	function logInt(int256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
	}

	function logUint(uint256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
	}

	function logString(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function logBool(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function logAddress(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function logBytes(bytes memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
	}

	function logBytes1(bytes1 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
	}

	function logBytes2(bytes2 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
	}

	function logBytes3(bytes3 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
	}

	function logBytes4(bytes4 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
	}

	function logBytes5(bytes5 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
	}

	function logBytes6(bytes6 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
	}

	function logBytes7(bytes7 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
	}

	function logBytes8(bytes8 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
	}

	function logBytes9(bytes9 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
	}

	function logBytes10(bytes10 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
	}

	function logBytes11(bytes11 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
	}

	function logBytes12(bytes12 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
	}

	function logBytes13(bytes13 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
	}

	function logBytes14(bytes14 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
	}

	function logBytes15(bytes15 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
	}

	function logBytes16(bytes16 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
	}

	function logBytes17(bytes17 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
	}

	function logBytes18(bytes18 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
	}

	function logBytes19(bytes19 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
	}

	function logBytes20(bytes20 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
	}

	function logBytes21(bytes21 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
	}

	function logBytes22(bytes22 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
	}

	function logBytes23(bytes23 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
	}

	function logBytes24(bytes24 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
	}

	function logBytes25(bytes25 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
	}

	function logBytes26(bytes26 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
	}

	function logBytes27(bytes27 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
	}

	function logBytes28(bytes28 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
	}

	function logBytes29(bytes29 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
	}

	function logBytes30(bytes30 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
	}

	function logBytes31(bytes31 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
	}

	function logBytes32(bytes32 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
	}

	function log(uint256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
	}

	function log(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function log(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function log(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function log(uint256 p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
	}

	function log(uint256 p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
	}

	function log(uint256 p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
	}

	function log(uint256 p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
	}

	function log(string memory p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
	}

	function log(string memory p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
	}

	function log(string memory p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
	}

	function log(string memory p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
	}

	function log(bool p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
	}

	function log(bool p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
	}

	function log(bool p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
	}

	function log(bool p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
	}

	function log(address p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
	}

	function log(address p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
	}

	function log(address p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
	}

	function log(address p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
	}

	function log(uint256 p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
	}

	function log(string memory p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
	}

	function log(string memory p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
	}

	function log(string memory p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
	}

	function log(string memory p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
	}

	function log(bool p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
	}

	function log(bool p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
	}

	function log(bool p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
	}

	function log(bool p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
	}

	function log(bool p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
	}

	function log(bool p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
	}

	function log(bool p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
	}

	function log(bool p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
	}

	function log(address p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
	}

	function log(address p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
	}

	function log(address p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
	}

	function log(address p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
	}

	function log(address p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
	}

	function log(address p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
	}

	function log(address p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
	}

	function log(address p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
	}

	function log(address p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
	}

	function log(address p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
	}

	function log(address p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
	}

	function log(address p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
	}

}


// File contracts/StringsExtended.sol

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)

pragma solidity ^0.8.0;



/**
 * @dev String operations.
 */
library StringsExtended {
    bytes16 private constant _SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `int256` to its ASCII `string` decimal representation.
     */
    function toString(int256 value) internal pure returns (string memory) {
        return
            string(
                abi.encodePacked(
                    value < 0 ? "-" : "",
                    toString(SignedMath.abs(value))
                )
            );
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexStringWithPrefix(
        uint256 value,
        uint256 length
    ) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(
        uint256 value,
        uint256 length
    ) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length);
        for (int256 i = 2 * int256(length) - 1; i >= 0; --i) {
            buffer[uint256(i)] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }

    /**
     * @dev Returns true if the two strings are equal.
     */
    function equal(
        string memory a,
        string memory b
    ) internal pure returns (bool) {
        return keccak256(bytes(a)) == keccak256(bytes(b));
    }
}


// File base64-sol/base64.sol@v1.1.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0;

/// @title Base64
/// @author Brecht Devos - <brecht@loopring.org>
/// @notice Provides functions for encoding/decoding base64
library Base64 {
    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    bytes  internal constant TABLE_DECODE = hex"0000000000000000000000000000000000000000000000000000000000000000"
                                            hex"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000"
                                            hex"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000"
                                            hex"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000";

    function encode(bytes memory data) internal pure returns (string memory) {
        if (data.length == 0) return '';

        // load the table into memory
        string memory table = TABLE_ENCODE;

        // multiply by 4/3 rounded up
        uint256 encodedLen = 4 * ((data.length + 2) / 3);

        // add some extra buffer at the end required for the writing
        string memory result = new string(encodedLen + 32);

        assembly {
            // set the actual output length
            mstore(result, encodedLen)

            // prepare the lookup table
            let tablePtr := add(table, 1)

            // input ptr
            let dataPtr := data
            let endPtr := add(dataPtr, mload(data))

            // result ptr, jump over length
            let resultPtr := add(result, 32)

            // run over the input, 3 bytes at a time
            for {} lt(dataPtr, endPtr) {}
            {
                // read 3 bytes
                dataPtr := add(dataPtr, 3)
                let input := mload(dataPtr)

                // write 4 characters
                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
                resultPtr := add(resultPtr, 1)
                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
                resultPtr := add(resultPtr, 1)
                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))
                resultPtr := add(resultPtr, 1)
                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))
                resultPtr := add(resultPtr, 1)
            }

            // padding with '='
            switch mod(mload(data), 3)
            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }
            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }
        }

        return result;
    }

    function decode(string memory _data) internal pure returns (bytes memory) {
        bytes memory data = bytes(_data);

        if (data.length == 0) return new bytes(0);
        require(data.length % 4 == 0, "invalid base64 decoder input");

        // load the table into memory
        bytes memory table = TABLE_DECODE;

        // every 4 characters represent 3 bytes
        uint256 decodedLen = (data.length / 4) * 3;

        // add some extra buffer at the end required for the writing
        bytes memory result = new bytes(decodedLen + 32);

        assembly {
            // padding with '='
            let lastBytes := mload(add(data, mload(data)))
            if eq(and(lastBytes, 0xFF), 0x3d) {
                decodedLen := sub(decodedLen, 1)
                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {
                    decodedLen := sub(decodedLen, 1)
                }
            }

            // set the actual output length
            mstore(result, decodedLen)

            // prepare the lookup table
            let tablePtr := add(table, 1)

            // input ptr
            let dataPtr := data
            let endPtr := add(dataPtr, mload(data))

            // result ptr, jump over length
            let resultPtr := add(result, 32)

            // run over the input, 4 characters at a time
            for {} lt(dataPtr, endPtr) {}
            {
               // read 4 characters
               dataPtr := add(dataPtr, 4)
               let input := mload(dataPtr)

               // write 3 bytes
               let output := add(
                   add(
                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),
                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),
                   add(
                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),
                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)
                    )
                )
                mstore(resultPtr, shl(232, output))
                resultPtr := add(resultPtr, 3)
            }
        }

        return result;
    }
}


// File contracts/Metadata.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

// import "./Problems.sol";



/// @title Metadata
/// @notice
/// @author @okwme
/// @dev The updateable and replaceable metadata contract

contract Metadata is Ownable {
    address payable public problems;
    uint256 constant radiusMultiplyer = 100;

    constructor() {}

    // string public baseURI = "https://";

    // /// @dev sets the baseURI can only be called by the owner
    // /// @param baseURI_ the new baseURI
    // function setbaseURI(string memory baseURI_) public onlyOwner {
    //     baseURI = baseURI_;
    // }

    // /// @dev generates the metadata
    // /// @param tokenId the tokenId
    // /// @return _ the metadata
    // function getMetadata(uint256 tokenId) public view returns (string memory) {
    //     return
    //         string(
    //             abi.encodePacked(baseURI, StringsExtended.toString(tokenId), ".json")
    //         );
    // }

    /**
     * @dev Throws if id doesn't exist
     */
    modifier existsModifier(uint256 id) {
        require(exists(id), "DOES NOT EXIST");
        _;
    }

    function exists(uint256 id) public view returns (bool) {
        return Problems(problems).ownerOf(id) != address(0);
    }

    /// @dev generates the metadata
    /// @param tokenId the tokenId
    function getMetadata(
        uint256 tokenId
    ) public view existsModifier(tokenId) returns (string memory) {
        return
            string(
                abi.encodePacked(
                    "data:application/json;base64,",
                    Base64.encode(
                        abi.encodePacked(
                            '{"name":"',
                            getName(tokenId),
                            '", "description": "asdf", "image": "',
                            getSVG(tokenId),
                            '",',
                            '"animation_url": "',
                            getHTML(tokenId),
                            '",',
                            '"attributes": ',
                            getAttributes(tokenId),
                            "}"
                        )
                    )
                )
            );
    }

    function getName(uint256 tokenId) public view returns (string memory) {
        return
            string(
                abi.encodePacked("Problem #", StringsExtended.toString(tokenId))
            );
    }

    function getHTML(uint256 tokenId) public view returns (string memory) {
        return
            string(
                abi.encodePacked(
                    "data:text/html;base64,",
                    Base64.encode(
                        abi.encodePacked(
                            "<html><body><img src='",
                            getSVG(tokenId),
                            "'></body></html>"
                        )
                    )
                )
            );
    }

    /// @dev function to generate a SVG String
    function getSVG(
        uint256 tokenId
    ) public view existsModifier(tokenId) returns (string memory) {
        return
            string(
                abi.encodePacked(
                    "data:image/svg+xml;base64,",
                    Base64.encode(
                        abi.encodePacked(
                            '<?xml version="1.0" encoding="utf-8"?><svg xmlns="http://www.w3.org/2000/svg"  height="100%" width="100%" viewBox="0 0 1000 1000" style="background-color:grey;"><style></style>',
                            getPath(tokenId),
                            '<text x="50" y="550" class="name">',
                            getName(tokenId),
                            "</text></svg>"
                        )
                    )
                )
            );
    }

    function getPath(uint256 tokenId) public view returns (string memory) {
        // const { seed, bodyCount, tickCount, bodiesProduced } = problem
        string memory path = "";
        (
            bytes32 seed,
            uint256 bodyCount,
            uint256 tickCount,
            uint256 bodiesProduced
        ) = Problems(problems).problems(tokenId);

        uint256[10] memory bodyIds = Problems(problems).getProblemBodyIds(
            tokenId
        );
        uint256 scalingFactor = Problems(problems).scalingFactor();
        for (uint256 i = 0; i < bodyCount; i++) {
            Problems.Body memory body = Problems(problems).getProblemBodyData(
                tokenId,
                bodyIds[i]
            );

            uint256 scaledRadius = body.radius *
                4 +
                radiusMultiplyer *
                scalingFactor;
            uint256 radiusRounded = (scaledRadius / scalingFactor);
            string memory radius = StringsExtended.toString(radiusRounded);
            string memory radiusDecimalsString = StringsExtended.toString(
                scaledRadius - (radiusRounded * scalingFactor)
            );

            uint256 pxScaled = body.px / scalingFactor;
            uint256 pxDecimals = body.px - (pxScaled * scalingFactor);
            string memory pxString = string(
                abi.encodePacked(
                    StringsExtended.toString(pxScaled),
                    ".",
                    StringsExtended.toString(pxDecimals)
                )
            );
            uint256 pyScaled = body.py / scalingFactor;
            uint256 pyDecimals = body.py - (pyScaled * scalingFactor);
            string memory pyString = string(
                abi.encodePacked(
                    StringsExtended.toString(pyScaled),
                    ".",
                    StringsExtended.toString(pyDecimals)
                )
            );
            string memory bodyIDString = StringsExtended.toString(body.bodyId);
            string memory transformOrigin = string(
                abi.encodePacked(
                    "transform-origin: ",
                    pxString,
                    "px ",
                    pyString,
                    "px; "
                )
            );
            path = string(
                abi.encodePacked(
                    path,
                    "<style> @keyframes moveEllipse",
                    bodyIDString,
                    " { 0% { ",
                    transformOrigin,
                    " transform: rotate(0deg) translate(0px, 10px); } 100% { ",
                    transformOrigin,
                    " transform: rotate(360deg) translate(0px, 10px); } }",
                    "ellipse#id-",
                    bodyIDString,
                    " { animation: moveEllipse",
                    bodyIDString,
                    " 4s infinite linear; animation-delay: -",
                    StringsExtended.toString(i),
                    "s; }</style>",
                    '<ellipse id="id-',
                    bodyIDString,
                    '" ry="',
                    radius,
                    ".",
                    radiusDecimalsString,
                    '" rx="',
                    radius,
                    ".",
                    radiusDecimalsString,
                    '" cy="',
                    pyString,
                    '" cx="',
                    pxString,
                    '" fill="#',
                    seedToColor(body.seed),
                    '" />'
                )
            );
        }

        return path;
    }

    function seedToColor(bytes32 seed) public view returns (string memory) {
        string memory result = StringsExtended.toHexString(
            uint256(seed) & 0xffffff,
            3
        );
        return result;
    }

    /// @dev generates the attributes as JSON String
    function getAttributes(
        uint256 tokenId
    ) internal view returns (string memory) {
        uint256 value = 0;
        uint256 value2 = 1;
        return
            string(
                abi.encodePacked(
                    "[",
                    '{"trait_type":"ASDF","value":"',
                    value,
                    '"}, {"trait_type":"ASDF2","value":"',
                    value2,
                    '"}]'
                )
            );
    }

    function updateProblemsAddress(address payable problems_) public onlyOwner {
        problems = problems_;
    }
}


// File contracts/Problems.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;



// import "./Solver.sol";

contract Problems is ERC721, Ownable {
    bool public paused;
    // TODO: update with actual start date
    uint256 public startDate = 4070908800; // Thu Jan 01 2099 00:00:00 GMT+0000 (___ CEST Berlin, ___ London, ___ NYC, ___ LA)

    uint256 public problemSupply;

    address public bodies;
    address public solver;
    address public metadata;

    address public wallet;

    uint256 public price = 0.01 ether;

    // TODO: confirm bodyIndex matches anybody.js for proof generation
    struct Body {
        uint256 bodyId;
        uint256 bodyStyle;
        uint256 bodyIndex;
        uint256 px;
        uint256 py;
        uint256 vx;
        uint256 vy;
        uint256 radius;
        bytes32 seed;
    }

    struct Problem {
        bytes32 seed;
        uint256 bodyCount;
        uint256 bodiesProduced;
        mapping(uint256 => Body) bodyData;
        uint256[10] bodyIds;
        uint256 tickCount;
    }

    mapping(uint256 => Problem) public problems;
    // mapping is body count to tocks to address
    mapping(uint256 => mapping(uint256 => address)) public verifiers;

    uint256 public constant maxVector = 10;
    uint256 public constant scalingFactor = 10 ** 3;
    uint256 public constant windowWidth = 1000 * scalingFactor;
    // uint256 public constant maxRadius = 13;
    uint256 public constant startingRadius = 2;

    event bodyAdded(
        uint256 problemId,
        uint256 bodyId,
        uint256 bodyStyle,
        uint256 tick,
        uint256 px,
        uint256 py,
        uint256 radius,
        bytes32 seed
    );

    event bodyRemoved(
        uint256 problemId,
        uint256 tick,
        uint256 bodyId,
        bytes32 seed
    );

    modifier onlySolver() {
        require(msg.sender == solver, "Only Solver can call");
        _;
    }

    modifier initialized() {
        require(solver != address(0), "Not initialized");
        require(bodies != address(0), "Not initialized");
        require(metadata != address(0), "Not initialized");
        require(wallet != address(0), "Not initialized");
        _;
    }

    event EthMoved(
        address indexed to,
        bool indexed success,
        bytes returnData,
        uint256 amount
    );

    constructor(
        address metadata_,
        address[] memory verifiers_,
        uint256[] memory verifiersTicks,
        uint256[] memory verifiersBodies
    ) ERC721("Anybody Problem", "ANY") {
        require(metadata_ != address(0), "Invalid metadata");
        wallet = msg.sender;
        metadata = metadata_;
        for (uint256 i = 0; i < verifiers_.length; i++) {
            require(verifiersTicks[i] > 0, "Invalid verifier tocks");
            require(verifiers_[i] != address(0), "Invalid verifier");
            verifiers[verifiersBodies[i]][verifiersTicks[i]] = verifiers_[i];
        }
    }

    receive() external payable {
        mint();
    }

    function tokenURI(
        uint256 id
    ) public view override(ERC721) returns (string memory) {
        return Metadata(metadata).getMetadata(id);
    }

    function updatePrice(uint256 price_) public onlyOwner {
        price = price_;
    }

    function updatePaused(bool paused_) public onlyOwner {
        paused = paused_;
    }

    function updateStartDate(uint256 startDate_) public onlyOwner {
        startDate = startDate_;
    }

    function updateVerifier(
        address verifier_,
        uint256 verifierBodies,
        uint256 verifierTicks
    ) public onlyOwner {
        verifiers[verifierBodies][verifierTicks] = verifier_;
    }

    function updateSolverAddress(address solver_) public onlyOwner {
        solver = solver_;
    }

    function updateMetadataAddress(address metadata_) public onlyOwner {
        metadata = metadata_;
    }

    function updateBodiesAddress(address bodies_) public onlyOwner {
        bodies = bodies_;
    }

    function updateWalletAddress(address wallet_) public onlyOwner {
        wallet = wallet_;
    }

    function generateSeed(uint256 tokenId) internal view returns (bytes32) {
        // TODO: add back blockhash
        return keccak256(abi.encodePacked(tokenId)); //, blockhash(block.number - 1)));
    }

    function mint() public payable {
        mint(msg.sender, 1);
    }

    function mint(
        address recipient,
        uint256 quantity
    ) public payable initialized {
        require(quantity <= 5, "Max 5");
        require(!paused, "Paused");
        require(block.timestamp >= startDate, "Not started");
        require(msg.value == quantity * price, "Invalid price");
        // (bool sent, bytes memory data) = wallet.call{value: msg.value}("");
        (bool sent, bytes memory data) = wallet.call{value: msg.value}("");
        emit EthMoved(wallet, sent, data, msg.value);
        for (uint256 i = 0; i < quantity; i++) {
            _internalMint(recipient);
        }
    }

    function mint(address recipient) public payable initialized {
        mint(recipient, 1);
    }

    function adminMint(address recipient) public initialized onlyOwner {
        _internalMint(recipient);
    }

    function _internalMint(address recipient) internal {
        problemSupply++;
        _mint(recipient, problemSupply);

        for (uint256 i = 0; i < 3; i++) {
            uint256 bodyId = Bodies(bodies).mintAndBurn(
                recipient,
                problemSupply
            );
            _addBody(problemSupply, bodyId, i, 1);
        }
        problems[problemSupply].seed = generateSeed(problemSupply);
        problems[problemSupply].bodyCount = 3;
    }

    function mintBody(uint256 problemId) public {
        require(!paused, "Paused");
        require(ownerOf(problemId) == msg.sender, "Not problem owner");
        require(
            problems[problemId].bodyCount < 10,
            "Cannot have more than 10 bodies"
        );
        uint256 bodyId = Bodies(bodies).mintAndBurn(msg.sender, problemId);
        uint256 i = problems[problemId].bodyCount;
        _addBody(problemId, bodyId, i, 1);
    }

    function addBody(uint256 problemId, uint256 bodyId) public {
        require(!paused, "Paused");
        require(ownerOf(problemId) == msg.sender, "Not problem owner");
        require(Bodies(bodies).ownerOf(bodyId) == msg.sender, "Not body owner");
        require(
            problems[problemId].bodyCount < 10,
            "Cannot have more than 10 bodies"
        );
        Bodies(bodies).burn(bodyId);
        uint256 i = problems[problemId].bodyCount;
        _addBody(problemId, bodyId, i, 0);
    }

    function removeBody(uint256 problemId, uint256 bodyId) public {
        require(!paused, "Paused");
        require(ownerOf(problemId) == msg.sender, "Not problem owner");
        require(
            problems[problemId].bodyCount > 3,
            "Cannot have less than 3 bodies"
        );
        Bodies(bodies).problemMint(msg.sender, bodyId);
        emit bodyRemoved(
            problemId,
            problems[problemId].tickCount,
            bodyId,
            problems[problemId].seed
        );
        uint256 bodyIndex = problems[problemId].bodyData[bodyId].bodyIndex;
        problems[problemId].bodyCount--;
        problems[problemId].bodyIds = _removeElement(
            problems[problemId].bodyIds,
            bodyIndex
        );
        delete problems[problemId].bodyData[bodyId];
    }

    function _removeElement(
        uint256[10] memory array,
        uint256 index
    ) internal pure returns (uint256[10] memory) {
        for (uint256 i = index; i < array.length - 1; i++) {
            array[i] = array[i + 1];
        }
        delete array[array.length - 1];
        return array;
    }

    function _addBody(
        uint256 problemId,
        uint256 bodyId,
        uint256 i,
        uint256 incrementBodiesProduced
    ) internal {
        bytes32 bodySeed = Bodies(bodies).seeds(bodyId);
        uint256 bodyStyle = Bodies(bodies).styles(bodyId);
        uint256 tickCount = problems[problemId].tickCount;
        Body memory bodyData;
        bodyData = getRandomValues(bodyId, bodySeed, bodyStyle, i);
        problems[problemId].bodyData[bodyId] = bodyData;
        problems[problemId].bodyIds[i] = bodyId;
        problems[problemId].bodyCount++;
        problems[problemId].bodiesProduced += incrementBodiesProduced;
        emit bodyAdded(
            problemId,
            bodyId,
            bodyStyle,
            tickCount,
            bodyData.px,
            bodyData.py,
            bodyData.radius,
            bodySeed
        );
    }

    // NOTE: this function uses i as input for radius, which means it's possible
    // for an owner to remove a body at index 0 and add back with a greater index
    // the greater index may collide with the index originally used or another body
    // the result is that there may be bodies with the same radius which is acceptable
    function getRandomValues(
        uint256 bodyId,
        bytes32 seed,
        uint256 bodyStyle,
        uint256 i
    ) public pure returns (Body memory) {
        Body memory body;
        body.seed = seed;

        bytes32 rand = keccak256(abi.encodePacked(seed, i));
        uint256 x = randomRange(0, windowWidth, rand);

        rand = keccak256(abi.encodePacked(rand));
        uint256 y = randomRange(0, windowWidth, rand);

        rand = keccak256(abi.encodePacked(rand));
        // console.log("rand");
        // console.logBytes32(rand);
        uint256 randRadius = randomRange(0, 3, rand);
        // console.log("randRadius");
        // console.log(randRadius);
        randRadius = (randRadius) * 5 + startingRadius;
        // console.log("randRadius");
        // console.log(randRadius);
        uint256 r = randRadius * scalingFactor;

        // console.log("maxVectorScaled");
        // console.log(maxVector * scalingFactor);
        body.bodyId = bodyId;
        body.bodyStyle = bodyStyle;
        body.px = x;
        body.py = y;
        body.vx = maxVector * scalingFactor;
        body.vy = maxVector * scalingFactor;
        body.radius = r;
        body.bodyIndex = i;

        return body;
    }

    function randomRange(
        uint256 min,
        uint256 max,
        bytes32 rand
    ) internal pure returns (uint256) {
        return min + (uint256(rand) % (max - min));
    }

    function getProblemBodyIds(
        uint256 problemId
    ) public view returns (uint256[10] memory) {
        return problems[problemId].bodyIds;
    }

    function getProblemBodyData(
        uint256 problemId,
        uint256 bodyId
    ) public view returns (Body memory) {
        return problems[problemId].bodyData[bodyId];
    }

    function updateProblemBodyCount(
        uint256 problemId,
        uint256 bodyCount
    ) public onlySolver {
        problems[problemId].bodyCount = bodyCount;
    }

    function updateProblemBodyIds(
        uint256 problemId,
        uint256[10] memory bodyIds
    ) public onlySolver {
        problems[problemId].bodyIds = bodyIds;
    }

    function updateProblemTickCount(
        uint256 problemId,
        uint256 tickCount
    ) public onlySolver {
        problems[problemId].tickCount = tickCount;
    }

    function updateProblemBody(
        uint256 problemId,
        uint256 bodyId,
        Body memory body
    ) public onlySolver {
        problems[problemId].bodyData[bodyId] = body;
    }

    /// @dev if mint fails to send eth to splitter, admin can recover
    // This should not be necessary but Berlin hardfork broke split before so this
    // is extra precaution.
    function recoverUnsuccessfulMintPayment(
        address payable _to
    ) public onlyOwner {
        uint256 amount = address(this).balance;
        (bool sent, bytes memory data) = _to.call{value: amount}("");
        emit EthMoved(_to, sent, data, amount);
    }
}


// File contracts/Nft_10_20Verifier.sol

// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 5109664962046880296849133193154203583946668889245032504146488310173947895989;
    uint256 constant deltax2 = 6647872284587391037195760782666650841217019320455285114466456315209901935156;
    uint256 constant deltay1 = 9666971882249144170287565214994259155347358974043738120765969407806563570061;
    uint256 constant deltay2 = 9274419835067770878202929853009566320044396379481820798967989158637468839426;

    
    uint256 constant IC0x = 662969233908929322640552391298043592146484573998239019211007988370642925305;
    uint256 constant IC0y = 3711295710632931899315474472992329193539814909076397360268156852743252229935;
    
    uint256 constant IC1x = 9372402739832825006460495049277956644965679727314236547428929982106813170704;
    uint256 constant IC1y = 9468309728540203187860900960542206419439129585670762391976552975969382658775;
    
    uint256 constant IC2x = 4555496404624135690994797862599788848979305669435975554342883191762433835792;
    uint256 constant IC2y = 21273533766066730714819616376078940546137312337814364432094151225266179049151;
    
    uint256 constant IC3x = 2505770495465426732562564614629740392177109757717752553177574778237913360698;
    uint256 constant IC3y = 16142483103866380902755515680183691171463890774081372879652330499341233860829;
    
    uint256 constant IC4x = 20147662368425292656912595764433652672091522876442821703960487565958031597868;
    uint256 constant IC4y = 1683268435684871620668846622912716573869807553641679602820061699420875749969;
    
    uint256 constant IC5x = 11982622687571740923393331022633761580312364392996756205311839186212550080571;
    uint256 constant IC5y = 17577838394618303493571940922130607972692090024635174498592141601115620860733;
    
    uint256 constant IC6x = 6557952286022018050909597358376605677364258088344111322589742199234485623355;
    uint256 constant IC6y = 9337243525539165729994186499992955613342092351955124635515569718291445045801;
    
    uint256 constant IC7x = 496972588523445750625539678340102639648799710403452878472148490647536657052;
    uint256 constant IC7y = 5637584697735633339425056905412887244460774155299682342578732797696984006842;
    
    uint256 constant IC8x = 13764927267499520090376483000347121215309220013485424944842403501092291054526;
    uint256 constant IC8y = 2160720048911401212950959060823436592406630703484985638168809543470087439847;
    
    uint256 constant IC9x = 11023385350732269606549195439871791277169781717550776232744741880565234830139;
    uint256 constant IC9y = 1742436545481802630007209638035935373392493322193936343382176585306350316363;
    
    uint256 constant IC10x = 13941413253051118815792206766023524828017671421825375127912628718056635327344;
    uint256 constant IC10y = 5624681133149026049747080128908810882994767344683827871092735867957959527307;
    
    uint256 constant IC11x = 2483979494258502097285154785975296430487620311524360485404104006754937480289;
    uint256 constant IC11y = 7396953629382170358553294277691261173188084009616876962485783870113848220051;
    
    uint256 constant IC12x = 3351362305475273936870591356743969217812323774264032589625643698136491641677;
    uint256 constant IC12y = 7414390804902984923804064393229311352427837474542291806296634444857373851578;
    
    uint256 constant IC13x = 17577647136218472647569984041082093074346164553451133167821271557322776036244;
    uint256 constant IC13y = 4184363268490158341220858557125227226492295108350467497937399044227634854000;
    
    uint256 constant IC14x = 19080477831128932285186072993194026456666778624844936145756496031488078687861;
    uint256 constant IC14y = 8494301385595000345550877711594781764161082220732224635184328172891386211243;
    
    uint256 constant IC15x = 3909054799799164535247869432873662983780940128960786614288478933366984206365;
    uint256 constant IC15y = 14393704683981135248743943316476212884791973264725508178606228746956869471944;
    
    uint256 constant IC16x = 5220840459561953751764093317338764016622366596026475610076081264715452011300;
    uint256 constant IC16y = 17074865347717455087006929635272875288953526243739425879170880761370611456102;
    
    uint256 constant IC17x = 1525681831467187535772070429385763010554822234813679810047015113057817650544;
    uint256 constant IC17y = 11530860041924597606903648552984779595635241440782927812405313272827251130510;
    
    uint256 constant IC18x = 7694347988251910576026245149148841737245988125833078976122373160728175453581;
    uint256 constant IC18y = 21448270490033301515784612630843517159715700046775516156656601626357496647452;
    
    uint256 constant IC19x = 6572902090893507725017580600538994714004034225065875700394315368538840951339;
    uint256 constant IC19y = 21198633207447073853186310703447351854472214753232335971037013474027310478639;
    
    uint256 constant IC20x = 21600951798192396137635439390846599166720435560139784116113641526448310039809;
    uint256 constant IC20y = 135406493410745422654031572073934685562777989100414254660109611482526536339;
    
    uint256 constant IC21x = 17713589524072936051100868404959858138092482770818969282989864678944386269819;
    uint256 constant IC21y = 4538318859859581655827490137042010189885331712302367413365409878760206072681;
    
    uint256 constant IC22x = 14714038488570534952023784059886070680848152854076057570606819987327779706829;
    uint256 constant IC22y = 21612903860754118324444228006874032034494787991424289000895137474429964613127;
    
    uint256 constant IC23x = 515265475114492954058694375431742187553586360071695698860587263117942717952;
    uint256 constant IC23y = 5167540426186146570689963532259749520878939254015566956072466820507212821145;
    
    uint256 constant IC24x = 2388565368672370592111690766426366233131395554547899137070833357630894841491;
    uint256 constant IC24y = 3617552465258457317285225290083808087005109902155655260031898162739964650954;
    
    uint256 constant IC25x = 15249885301567107211225743955349498852131661348240203526145334820639033923185;
    uint256 constant IC25y = 15010956406647977378731001327685765286303397566343112721312821161722537105068;
    
    uint256 constant IC26x = 21391261750800055675592663358884912585653461354289684071160919531682454577084;
    uint256 constant IC26y = 8702282815586671398130938257141507389565804555658285738276717625341926439990;
    
    uint256 constant IC27x = 6823245414589888449029636200394912393192850301045203569992011202973041333292;
    uint256 constant IC27y = 10043873944200418228123869379159317595148111795640610395992001631134071847581;
    
    uint256 constant IC28x = 18874594108412811264800131279990869619250635146537094020956088745263282967795;
    uint256 constant IC28y = 10571467917760194308512477419094619000946165625032036318913834517769485006886;
    
    uint256 constant IC29x = 9470036412855910050634964251047013121211598172487904176277171906493197978552;
    uint256 constant IC29y = 8970721459157699528654259870640515886932410032597004447466187653192718308336;
    
    uint256 constant IC30x = 10454670547689653773736166118452926323115560853498475473661603191289923433400;
    uint256 constant IC30y = 404657831272641066714375366006343150948774227492263109021777166471217378236;
    
    uint256 constant IC31x = 16626373782134874380611471952761047355987420753120774878571604180947845554519;
    uint256 constant IC31y = 16320077552134189778287836365214293893781271629091435622265377883239617863497;
    
    uint256 constant IC32x = 10178920507479548312254304154247661740484913428656660495699418050883773676750;
    uint256 constant IC32y = 15873386843759897903102581944878126309968929857628683254626330274230249649075;
    
    uint256 constant IC33x = 1511668142403513995364098573465356256721329328775437807055527282599436658741;
    uint256 constant IC33y = 6910794049147690778100685247270792502298567058589894415846471374903179694167;
    
    uint256 constant IC34x = 5027534978525878058572842499249860224507320284684776917657427959180861685952;
    uint256 constant IC34y = 11597746375989646499127941856523672765323982767926430903116779973870277030933;
    
    uint256 constant IC35x = 2894615464889609612449678192592881197400954325306177412777368041672618381681;
    uint256 constant IC35y = 19186606389070900210268007353078566517937296428186189160506490266382889164635;
    
    uint256 constant IC36x = 10269934641866417365435514928105307887730444411821042223768057102190529768975;
    uint256 constant IC36y = 8700054833555669018693858976392492609873844154010747687904067972112857539468;
    
    uint256 constant IC37x = 13102639184431053289341932992464887448563528092692664798484346742111788383497;
    uint256 constant IC37y = 18611380613354528338340854755651010371886568776298964421170146080468243229942;
    
    uint256 constant IC38x = 5863925248742354425361087816831740267610625628564287994420357590771438479809;
    uint256 constant IC38y = 17467819088764132682104739332746286852792554797910876919954092751190752348297;
    
    uint256 constant IC39x = 17351361016212987683970355666327808692182578492675040963652940787722865493150;
    uint256 constant IC39y = 16024511855830116870953779456515936402787138368434270144157417281101627744614;
    
    uint256 constant IC40x = 7984162191233583205989989272613746486411613186071484230236190796637749580225;
    uint256 constant IC40y = 13554928414735166863015343628278112622526671789561484256782310432759679771824;
    
    uint256 constant IC41x = 6452264998608826360575808252670450213361599637731176703583362951764566259963;
    uint256 constant IC41y = 15953637723772143296028311283384203674090023449990677284726537871584724976906;
    
    uint256 constant IC42x = 20051241992216979593137387967435691743999690755937389891195736769455046174911;
    uint256 constant IC42y = 10612246660646726880380073885006610003605752189062669512915448504434076823885;
    
    uint256 constant IC43x = 12498634896515118661376081869479662928137729766601032993601065892902152838855;
    uint256 constant IC43y = 4259786837862641011757321855038434474956980322214038611816474743570788518264;
    
    uint256 constant IC44x = 7109178584285437732143944851288314404525033141009382976582026108414847416541;
    uint256 constant IC44y = 21179480666740093375627969024473020115224404030156746650355480220873044564436;
    
    uint256 constant IC45x = 11046907301359510696874444336068225389814288181154701363198235670506898782403;
    uint256 constant IC45y = 21192438434405134470771857330781321452227749205234787654826268349812999000472;
    
    uint256 constant IC46x = 10634802254685491344116855518809587124315740053044181430394317282073351576;
    uint256 constant IC46y = 9172779152488639396503959461779690832521036097117048744475452112619061044085;
    
    uint256 constant IC47x = 14243076099882244924556365199763989887453075471874308765176739106209231470649;
    uint256 constant IC47y = 13383221673615476454730583995422960049205567448628084831197559221827168095520;
    
    uint256 constant IC48x = 18169252909487493345606216253337403403672251366673851146057132210598139738059;
    uint256 constant IC48y = 10522531237659767892253901258064758911101884117112211567268478804559011369943;
    
    uint256 constant IC49x = 20515489689085335763173616052730799065623749214786865414007256555822114438068;
    uint256 constant IC49y = 20275295437593276876626046995973537249389535855883056407322876274123240760021;
    
    uint256 constant IC50x = 18816021993416888119506315468103090194933303665897090337961196913600737108374;
    uint256 constant IC50y = 16311290211991545917782363402239690654937217318908006214677021498954128327578;
    
    uint256 constant IC51x = 20453498500401529625517570329813749244006364302916647610320799451030188308854;
    uint256 constant IC51y = 12767100996309597482219649071029993599203301891400895668486690843460795266920;
    
    uint256 constant IC52x = 16400002083910408372254949637143273706357640005784865177187506726800903067548;
    uint256 constant IC52y = 18866674519906487414746809079572187653936627883872546195113154003297521566495;
    
    uint256 constant IC53x = 2670734915510710963960079417731782330031847485527006181988631148701253819764;
    uint256 constant IC53y = 10784116268136411063051345833859815952438984098838477978629452875141404806241;
    
    uint256 constant IC54x = 21395322788399639735456831737368145757249525702189350047260812429178158670572;
    uint256 constant IC54y = 17337304850960529170838233807750352938539153180171187080222219537695312034408;
    
    uint256 constant IC55x = 13014970737993375850264185631103413190948420884865793410372373037113286697327;
    uint256 constant IC55y = 3479371796930495475289492426832233008825566305556341147690151683620384068425;
    
    uint256 constant IC56x = 10143977705065236748331279011864310361454825538164233607637271669953721591694;
    uint256 constant IC56y = 6044910156787591857161748620540275512470424638036152188744916852968412213485;
    
    uint256 constant IC57x = 13423288462404034676686855031123538450243446940027017327954616299109289252944;
    uint256 constant IC57y = 19835281892416590405550033163810697851593995367156790363222453458589332408901;
    
    uint256 constant IC58x = 13680576648272275247531217736699322660048522945191195852444443987618755473854;
    uint256 constant IC58y = 3836763253234258849557142715643989351817574011566371152550987801436350462644;
    
    uint256 constant IC59x = 7774937103517052613668202691725061247362827343658861316662872801994391047294;
    uint256 constant IC59y = 18248320054668018359842501481684223256560756881404132072066502794098214515353;
    
    uint256 constant IC60x = 14202524486498016246680646848267069398488242366373397861988857656684837645790;
    uint256 constant IC60y = 21453582985945737060351466803219724131943356817418948117085927866717567651042;
    
    uint256 constant IC61x = 12959767050602888919311293911658271511496494190703012141477589157053735441973;
    uint256 constant IC61y = 3894040428428658074364012670387707974402148313476063501171923944945297959553;
    
    uint256 constant IC62x = 10337327577878810828522733446297177902187341718730007617037963614856162289644;
    uint256 constant IC62y = 9493701832798655584602248211303584497324666200816026008509918830465415767753;
    
    uint256 constant IC63x = 2998218908215178778827660398670998119389822379973388304084340667950182936075;
    uint256 constant IC63y = 3986063109479187923984725601241918096834659300226146921360223900375738898470;
    
    uint256 constant IC64x = 8576085175165178637379069456163686219963791617926467206086639366458419377676;
    uint256 constant IC64y = 2255320444931580456994882160924555047642709600578584813479639246747722995527;
    
    uint256 constant IC65x = 2235040998031439565153379537174544825866009023451595399573979613026584107481;
    uint256 constant IC65y = 16518804013110738164822220809274841238901963326330982257087414557913859683924;
    
    uint256 constant IC66x = 12523846238935042618561338869683866308653217477247883390373222888967116297778;
    uint256 constant IC66y = 310413008226581526622223415724580205302407605699168802347097710491181864862;
    
    uint256 constant IC67x = 10679130041265187318887624177730791049220862431730958962707765926080102687859;
    uint256 constant IC67y = 4411406586426898574673073887959460906591356057934322910312776675536270183959;
    
    uint256 constant IC68x = 7843365526182857405701261288910768138278610775829895467734779096758644240010;
    uint256 constant IC68y = 16865332157494480624799062765148400643781134698247691929659686238934238038780;
    
    uint256 constant IC69x = 15017397323664691422025883439853456158897622298761616732078045297241271565447;
    uint256 constant IC69y = 16516448352053851970841024386737153633721536491538270489800191851297900999791;
    
    uint256 constant IC70x = 2943094938225881683361247498072891483083364670801820306216900664411608772357;
    uint256 constant IC70y = 14609028616732903228647706602373336780003858040595187137503753770466564270127;
    
    uint256 constant IC71x = 2163517971765282612782529355024288690819192281607893442761889451617658230819;
    uint256 constant IC71y = 9061341798574557592783552537817771584196002697757603549986968927384804287964;
    
    uint256 constant IC72x = 752613718332531206872868183743939695842286168228026876502918538549870329516;
    uint256 constant IC72y = 6611540086110057292801774473638995265761039383211505379726013738270355994845;
    
    uint256 constant IC73x = 16310593930819082993345329434918557150513573817750731459084226524132976524967;
    uint256 constant IC73y = 5119982857691807355396738219085017950146064207183233808471647822379721902618;
    
    uint256 constant IC74x = 428264566623893639879692936388156371104594232428369013380266392701797363477;
    uint256 constant IC74y = 4768553758703555442094521075118945901156629404232294485350047424324048882508;
    
    uint256 constant IC75x = 771977470979317283319513055181254005840639889382144485913800815210847226959;
    uint256 constant IC75y = 3171351919750427250469340000815638399492514757119595370114567584726172098240;
    
    uint256 constant IC76x = 6213719044288173422968128890181986535457139215726553942824319272608868240767;
    uint256 constant IC76y = 9444160813196204139710216348044434397599512904177746252072498602032815198353;
    
    uint256 constant IC77x = 19548172609751783648790925103039266463830634334030151666308242187897280071371;
    uint256 constant IC77y = 19575173382885189127684993083561371980008938272583947425477914060462368686136;
    
    uint256 constant IC78x = 10270277780544777088414760833672064445489290817154967819435912245227322455063;
    uint256 constant IC78y = 6791396826711460996865946810340158344948193256851014320080908657066243750522;
    
    uint256 constant IC79x = 8004219811330693866669861432300222543396099636472381471477187329018718432471;
    uint256 constant IC79y = 16752772228674396238625311051251021178117237241407391395080040926778062726166;
    
    uint256 constant IC80x = 6146281588803988841033442471529544885804821963149732502395802170774435904103;
    uint256 constant IC80y = 10572888254001223618930222675315781310671554541066361731124464924822479563340;
    
    uint256 constant IC81x = 8294293880937621595977741159622107598899807169528703954046656834043369546850;
    uint256 constant IC81y = 4706260758136351758639366483779605951002522171039285616772457010195334536780;
    
    uint256 constant IC82x = 2129465547950987959716730634824480891908955499829653221631236614982311692412;
    uint256 constant IC82y = 14460470225894385382277346361734602614866579147442619554595356129605553497338;
    
    uint256 constant IC83x = 19975884751423915152335479944330606910924601114861982272311217761636499332287;
    uint256 constant IC83y = 3302312442397696425357173043893791630582250265789125655266207443953648364645;
    
    uint256 constant IC84x = 9088475775357372187137825221718458246867262747063812174830143687016246583670;
    uint256 constant IC84y = 17321430898947139953654626029010871947142092992750277753497265823755191744591;
    
    uint256 constant IC85x = 15784719141393836761914473505062970158734432558346282872869212747075680496198;
    uint256 constant IC85y = 1787923322986280437265965847208266245181444267349856014768077750513608992676;
    
    uint256 constant IC86x = 16610113247535704030780647235312519471937769255333535820195881179991561405649;
    uint256 constant IC86y = 6799879482261930914632281543985464970289681304151829466069332351345507104828;
    
    uint256 constant IC87x = 7075096548814278401624815456423862394474596223151286054198257882928643043349;
    uint256 constant IC87y = 11635193999221300136234751079121785424018706420240502457247441166721165333918;
    
    uint256 constant IC88x = 8521387122384734791921128212074954748434789487147526357667279496782367553295;
    uint256 constant IC88y = 857848268219328868716771599891035352078927659525812196899492279777433845185;
    
    uint256 constant IC89x = 7301022385080436883304815440251105216057697806804459961733313649196631880012;
    uint256 constant IC89y = 5585996393354342674464150435830784182269707260030706688785342208558827437973;
    
    uint256 constant IC90x = 21625455400803318636448828210946708858229302774971639020714243344339656661727;
    uint256 constant IC90y = 20266694344532217426044358805093626334877343777733469802956005624640492712695;
    
    uint256 constant IC91x = 8726175884684469517601831177912096528133481396439652461795264745133270169655;
    uint256 constant IC91y = 12899813178364430148452948542172809826625979464596852537608137841191160501861;
    
    uint256 constant IC92x = 12270145543553981857129137029053312907193355827105554465835828116263581159234;
    uint256 constant IC92y = 18381779629808472213947510245559784310482274745453362361183181862468462584512;
    
    uint256 constant IC93x = 8059553889343810153520697300698740776360328356553546709833686348758950688249;
    uint256 constant IC93y = 14670365318233965846969875827535668998891193531672395891620294507366526782323;
    
    uint256 constant IC94x = 18617843713135084577049272477000231596314278132245971836176488966221767389153;
    uint256 constant IC94y = 5131926696843497871758036346493545540295051341815136669283555273076254401245;
    
    uint256 constant IC95x = 1031979912428410961225524819400990781941171738030279859654900004662851889114;
    uint256 constant IC95y = 17521374953303542295803869363359663872792573229163843758993252211414986179011;
    
    uint256 constant IC96x = 18648123795035860890750921221708117015484024471119193539925267294256614502758;
    uint256 constant IC96y = 3381516919217922783321945248249992278523409573478571540834384805392347790345;
    
    uint256 constant IC97x = 14324672952220578618133425388711542659326118216269979683727361775946707443628;
    uint256 constant IC97y = 9408386488347000153890212392618220255894023345874545383595890060342127645866;
    
    uint256 constant IC98x = 12111875605207692238671139968707592468699510005532346808085812180404995794708;
    uint256 constant IC98y = 15543511974388232902890617325760011439389585052578159524044941483832575126553;
    
    uint256 constant IC99x = 1671284263379187764861474707084132378514711525120824916394638467003632433175;
    uint256 constant IC99y = 11210569624990296158556699054503302744928878125878772950315053587709654504284;
    
    uint256 constant IC100x = 10788103472269242463267232331487022218120528180116748295740499992967666049428;
    uint256 constant IC100y = 15977373407495756792037631044739622781866294518555958440621439667760656615760;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[100] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                
                g1_mulAccC(_pVk, IC33x, IC33y, calldataload(add(pubSignals, 1024)))
                
                g1_mulAccC(_pVk, IC34x, IC34y, calldataload(add(pubSignals, 1056)))
                
                g1_mulAccC(_pVk, IC35x, IC35y, calldataload(add(pubSignals, 1088)))
                
                g1_mulAccC(_pVk, IC36x, IC36y, calldataload(add(pubSignals, 1120)))
                
                g1_mulAccC(_pVk, IC37x, IC37y, calldataload(add(pubSignals, 1152)))
                
                g1_mulAccC(_pVk, IC38x, IC38y, calldataload(add(pubSignals, 1184)))
                
                g1_mulAccC(_pVk, IC39x, IC39y, calldataload(add(pubSignals, 1216)))
                
                g1_mulAccC(_pVk, IC40x, IC40y, calldataload(add(pubSignals, 1248)))
                
                g1_mulAccC(_pVk, IC41x, IC41y, calldataload(add(pubSignals, 1280)))
                
                g1_mulAccC(_pVk, IC42x, IC42y, calldataload(add(pubSignals, 1312)))
                
                g1_mulAccC(_pVk, IC43x, IC43y, calldataload(add(pubSignals, 1344)))
                
                g1_mulAccC(_pVk, IC44x, IC44y, calldataload(add(pubSignals, 1376)))
                
                g1_mulAccC(_pVk, IC45x, IC45y, calldataload(add(pubSignals, 1408)))
                
                g1_mulAccC(_pVk, IC46x, IC46y, calldataload(add(pubSignals, 1440)))
                
                g1_mulAccC(_pVk, IC47x, IC47y, calldataload(add(pubSignals, 1472)))
                
                g1_mulAccC(_pVk, IC48x, IC48y, calldataload(add(pubSignals, 1504)))
                
                g1_mulAccC(_pVk, IC49x, IC49y, calldataload(add(pubSignals, 1536)))
                
                g1_mulAccC(_pVk, IC50x, IC50y, calldataload(add(pubSignals, 1568)))
                
                g1_mulAccC(_pVk, IC51x, IC51y, calldataload(add(pubSignals, 1600)))
                
                g1_mulAccC(_pVk, IC52x, IC52y, calldataload(add(pubSignals, 1632)))
                
                g1_mulAccC(_pVk, IC53x, IC53y, calldataload(add(pubSignals, 1664)))
                
                g1_mulAccC(_pVk, IC54x, IC54y, calldataload(add(pubSignals, 1696)))
                
                g1_mulAccC(_pVk, IC55x, IC55y, calldataload(add(pubSignals, 1728)))
                
                g1_mulAccC(_pVk, IC56x, IC56y, calldataload(add(pubSignals, 1760)))
                
                g1_mulAccC(_pVk, IC57x, IC57y, calldataload(add(pubSignals, 1792)))
                
                g1_mulAccC(_pVk, IC58x, IC58y, calldataload(add(pubSignals, 1824)))
                
                g1_mulAccC(_pVk, IC59x, IC59y, calldataload(add(pubSignals, 1856)))
                
                g1_mulAccC(_pVk, IC60x, IC60y, calldataload(add(pubSignals, 1888)))
                
                g1_mulAccC(_pVk, IC61x, IC61y, calldataload(add(pubSignals, 1920)))
                
                g1_mulAccC(_pVk, IC62x, IC62y, calldataload(add(pubSignals, 1952)))
                
                g1_mulAccC(_pVk, IC63x, IC63y, calldataload(add(pubSignals, 1984)))
                
                g1_mulAccC(_pVk, IC64x, IC64y, calldataload(add(pubSignals, 2016)))
                
                g1_mulAccC(_pVk, IC65x, IC65y, calldataload(add(pubSignals, 2048)))
                
                g1_mulAccC(_pVk, IC66x, IC66y, calldataload(add(pubSignals, 2080)))
                
                g1_mulAccC(_pVk, IC67x, IC67y, calldataload(add(pubSignals, 2112)))
                
                g1_mulAccC(_pVk, IC68x, IC68y, calldataload(add(pubSignals, 2144)))
                
                g1_mulAccC(_pVk, IC69x, IC69y, calldataload(add(pubSignals, 2176)))
                
                g1_mulAccC(_pVk, IC70x, IC70y, calldataload(add(pubSignals, 2208)))
                
                g1_mulAccC(_pVk, IC71x, IC71y, calldataload(add(pubSignals, 2240)))
                
                g1_mulAccC(_pVk, IC72x, IC72y, calldataload(add(pubSignals, 2272)))
                
                g1_mulAccC(_pVk, IC73x, IC73y, calldataload(add(pubSignals, 2304)))
                
                g1_mulAccC(_pVk, IC74x, IC74y, calldataload(add(pubSignals, 2336)))
                
                g1_mulAccC(_pVk, IC75x, IC75y, calldataload(add(pubSignals, 2368)))
                
                g1_mulAccC(_pVk, IC76x, IC76y, calldataload(add(pubSignals, 2400)))
                
                g1_mulAccC(_pVk, IC77x, IC77y, calldataload(add(pubSignals, 2432)))
                
                g1_mulAccC(_pVk, IC78x, IC78y, calldataload(add(pubSignals, 2464)))
                
                g1_mulAccC(_pVk, IC79x, IC79y, calldataload(add(pubSignals, 2496)))
                
                g1_mulAccC(_pVk, IC80x, IC80y, calldataload(add(pubSignals, 2528)))
                
                g1_mulAccC(_pVk, IC81x, IC81y, calldataload(add(pubSignals, 2560)))
                
                g1_mulAccC(_pVk, IC82x, IC82y, calldataload(add(pubSignals, 2592)))
                
                g1_mulAccC(_pVk, IC83x, IC83y, calldataload(add(pubSignals, 2624)))
                
                g1_mulAccC(_pVk, IC84x, IC84y, calldataload(add(pubSignals, 2656)))
                
                g1_mulAccC(_pVk, IC85x, IC85y, calldataload(add(pubSignals, 2688)))
                
                g1_mulAccC(_pVk, IC86x, IC86y, calldataload(add(pubSignals, 2720)))
                
                g1_mulAccC(_pVk, IC87x, IC87y, calldataload(add(pubSignals, 2752)))
                
                g1_mulAccC(_pVk, IC88x, IC88y, calldataload(add(pubSignals, 2784)))
                
                g1_mulAccC(_pVk, IC89x, IC89y, calldataload(add(pubSignals, 2816)))
                
                g1_mulAccC(_pVk, IC90x, IC90y, calldataload(add(pubSignals, 2848)))
                
                g1_mulAccC(_pVk, IC91x, IC91y, calldataload(add(pubSignals, 2880)))
                
                g1_mulAccC(_pVk, IC92x, IC92y, calldataload(add(pubSignals, 2912)))
                
                g1_mulAccC(_pVk, IC93x, IC93y, calldataload(add(pubSignals, 2944)))
                
                g1_mulAccC(_pVk, IC94x, IC94y, calldataload(add(pubSignals, 2976)))
                
                g1_mulAccC(_pVk, IC95x, IC95y, calldataload(add(pubSignals, 3008)))
                
                g1_mulAccC(_pVk, IC96x, IC96y, calldataload(add(pubSignals, 3040)))
                
                g1_mulAccC(_pVk, IC97x, IC97y, calldataload(add(pubSignals, 3072)))
                
                g1_mulAccC(_pVk, IC98x, IC98y, calldataload(add(pubSignals, 3104)))
                
                g1_mulAccC(_pVk, IC99x, IC99y, calldataload(add(pubSignals, 3136)))
                
                g1_mulAccC(_pVk, IC100x, IC100y, calldataload(add(pubSignals, 3168)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ∈ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            
            checkField(calldataload(add(_pubSignals, 1024)))
            
            checkField(calldataload(add(_pubSignals, 1056)))
            
            checkField(calldataload(add(_pubSignals, 1088)))
            
            checkField(calldataload(add(_pubSignals, 1120)))
            
            checkField(calldataload(add(_pubSignals, 1152)))
            
            checkField(calldataload(add(_pubSignals, 1184)))
            
            checkField(calldataload(add(_pubSignals, 1216)))
            
            checkField(calldataload(add(_pubSignals, 1248)))
            
            checkField(calldataload(add(_pubSignals, 1280)))
            
            checkField(calldataload(add(_pubSignals, 1312)))
            
            checkField(calldataload(add(_pubSignals, 1344)))
            
            checkField(calldataload(add(_pubSignals, 1376)))
            
            checkField(calldataload(add(_pubSignals, 1408)))
            
            checkField(calldataload(add(_pubSignals, 1440)))
            
            checkField(calldataload(add(_pubSignals, 1472)))
            
            checkField(calldataload(add(_pubSignals, 1504)))
            
            checkField(calldataload(add(_pubSignals, 1536)))
            
            checkField(calldataload(add(_pubSignals, 1568)))
            
            checkField(calldataload(add(_pubSignals, 1600)))
            
            checkField(calldataload(add(_pubSignals, 1632)))
            
            checkField(calldataload(add(_pubSignals, 1664)))
            
            checkField(calldataload(add(_pubSignals, 1696)))
            
            checkField(calldataload(add(_pubSignals, 1728)))
            
            checkField(calldataload(add(_pubSignals, 1760)))
            
            checkField(calldataload(add(_pubSignals, 1792)))
            
            checkField(calldataload(add(_pubSignals, 1824)))
            
            checkField(calldataload(add(_pubSignals, 1856)))
            
            checkField(calldataload(add(_pubSignals, 1888)))
            
            checkField(calldataload(add(_pubSignals, 1920)))
            
            checkField(calldataload(add(_pubSignals, 1952)))
            
            checkField(calldataload(add(_pubSignals, 1984)))
            
            checkField(calldataload(add(_pubSignals, 2016)))
            
            checkField(calldataload(add(_pubSignals, 2048)))
            
            checkField(calldataload(add(_pubSignals, 2080)))
            
            checkField(calldataload(add(_pubSignals, 2112)))
            
            checkField(calldataload(add(_pubSignals, 2144)))
            
            checkField(calldataload(add(_pubSignals, 2176)))
            
            checkField(calldataload(add(_pubSignals, 2208)))
            
            checkField(calldataload(add(_pubSignals, 2240)))
            
            checkField(calldataload(add(_pubSignals, 2272)))
            
            checkField(calldataload(add(_pubSignals, 2304)))
            
            checkField(calldataload(add(_pubSignals, 2336)))
            
            checkField(calldataload(add(_pubSignals, 2368)))
            
            checkField(calldataload(add(_pubSignals, 2400)))
            
            checkField(calldataload(add(_pubSignals, 2432)))
            
            checkField(calldataload(add(_pubSignals, 2464)))
            
            checkField(calldataload(add(_pubSignals, 2496)))
            
            checkField(calldataload(add(_pubSignals, 2528)))
            
            checkField(calldataload(add(_pubSignals, 2560)))
            
            checkField(calldataload(add(_pubSignals, 2592)))
            
            checkField(calldataload(add(_pubSignals, 2624)))
            
            checkField(calldataload(add(_pubSignals, 2656)))
            
            checkField(calldataload(add(_pubSignals, 2688)))
            
            checkField(calldataload(add(_pubSignals, 2720)))
            
            checkField(calldataload(add(_pubSignals, 2752)))
            
            checkField(calldataload(add(_pubSignals, 2784)))
            
            checkField(calldataload(add(_pubSignals, 2816)))
            
            checkField(calldataload(add(_pubSignals, 2848)))
            
            checkField(calldataload(add(_pubSignals, 2880)))
            
            checkField(calldataload(add(_pubSignals, 2912)))
            
            checkField(calldataload(add(_pubSignals, 2944)))
            
            checkField(calldataload(add(_pubSignals, 2976)))
            
            checkField(calldataload(add(_pubSignals, 3008)))
            
            checkField(calldataload(add(_pubSignals, 3040)))
            
            checkField(calldataload(add(_pubSignals, 3072)))
            
            checkField(calldataload(add(_pubSignals, 3104)))
            
            checkField(calldataload(add(_pubSignals, 3136)))
            
            checkField(calldataload(add(_pubSignals, 3168)))
            
            checkField(calldataload(add(_pubSignals, 3200)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }


// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}


// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}


// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v4.9.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;



/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * The default value of {decimals} is 18. To change this, you should override
 * this function so it returns a different value.
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the default value returned by this function, unless
     * it's overridden.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `from` to `to`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     */
    function _transfer(address from, address to, uint256 amount) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
            // decrementing then incrementing.
            _balances[to] += amount;
        }

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        unchecked {
            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
            _balances[account] += amount;
        }
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
            // Overflow not possible: amount <= accountBalance <= totalSupply.
            _totalSupply -= amount;
        }

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
}


// File contracts/Tocks.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


contract Tocks is ERC20, Ownable {
    address public solver;
    address payable public problems;
    address public bodies;

    modifier onlySolver() {
        require(msg.sender == solver, "Only Solver can call");
        _;
    }

    modifier onlyBodies() {
        require(msg.sender == bodies, "Only Bodies can call");
        _;
    }

    constructor(
        address payable problems_,
        address bodies_
    ) ERC20("Tocks", "TICK") {
        updateProblemsAddress(problems_);
        updateBodiesAddress(bodies_);
    }

    function updateProblemsAddress(address payable problems_) public onlyOwner {
        problems = problems_;
    }

    function updateBodiesAddress(address bodies_) public onlyOwner {
        bodies = bodies_;
    }

    function updateSolverAddress(address solver_) public onlyOwner {
        solver = solver_;
    }

    function allowance(
        address owner,
        address spender
    ) public view virtual override returns (uint256) {
        if (spender == problems || spender == bodies) {
            return type(uint256).max;
        }
        return super.allowance(owner, spender);
    }

    function burn(address from, uint256 amount) public onlyBodies {
        _burn(from, amount);
    }

    function mint(address to, uint256 amount) public onlySolver {
        _mint(to, amount);
    }
}


// File contracts/Solver.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;










contract Solver is Ownable {
    address payable public problems;
    address public tocks;

    uint256[11] public bodyBoost = [
        0, // 0th body, just for easier indexing
        0, // 1st body
        0, // 2nd body
        1, // 3rd body
        2, // 4th body
        4, // 5th body
        8, // 6th body
        16, // 7th body
        32, // 8th body
        64, //9th body
        128 // 10th body
    ];

    event Solved(
        uint256 indexed problemId,
        uint256 indexed previousTickCount,
        uint256 indexed tickCount
    );

    constructor(address payable problems_, address tocks_) {
        problems = problems_;
        tocks = tocks_;
    }

    fallback() external {
        revert("no fallback function");
    }

    function updateProblemsAddress(address payable problems_) public onlyOwner {
        problems = problems_;
    }

    function updateTocksAddress(address tocks_) public onlyOwner {
        tocks = tocks_;
    }

    function solveProblem(
        uint256 problemId,
        uint256 tickCount,
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[] memory input
    ) public {
        (, uint256 bodyCount, , uint256 previousTickCount) = Problems(problems)
            .problems(problemId);
        uint256 numberOfBodies = bodyCount;

        uint256 numberOfInputs = numberOfBodies * 5 * 2;
        require(input.length == numberOfInputs, "Invalid input length");
        address verifier = Problems(problems).verifiers(
            numberOfBodies,
            tickCount
        );

        if (numberOfBodies == 3) {
            require(
                Groth16Verifier3(verifier).verifyProof(
                    a,
                    b,
                    c,
                    convertTo30(input)
                ),
                "Invalid 3 body proof"
            );
        } else if (numberOfBodies == 4) {
            require(
                Groth16Verifier4(verifier).verifyProof(
                    a,
                    b,
                    c,
                    convertTo40(input)
                ),
                "Invalid 4 body proof"
            );
        } else if (numberOfBodies == 5) {
            require(
                Groth16Verifier5(verifier).verifyProof(
                    a,
                    b,
                    c,
                    convertTo50(input)
                ),
                "Invalid 5 body proof"
            );
        } else if (numberOfBodies == 6) {
            require(
                Groth16Verifier6(verifier).verifyProof(
                    a,
                    b,
                    c,
                    convertTo60(input)
                ),
                "Invalid 6 body proof"
            );
        } else if (numberOfBodies == 7) {
            require(
                Groth16Verifier7(verifier).verifyProof(
                    a,
                    b,
                    c,
                    convertTo70(input)
                ),
                "Invalid 7 body proof"
            );
        } else if (numberOfBodies == 8) {
            require(
                Groth16Verifier8(verifier).verifyProof(
                    a,
                    b,
                    c,
                    convertTo80(input)
                ),
                "Invalid 8 body proof"
            );
        } else if (numberOfBodies == 9) {
            require(
                Groth16Verifier9(verifier).verifyProof(
                    a,
                    b,
                    c,
                    convertTo90(input)
                ),
                "Invalid 9 body proof"
            );
        } else if (numberOfBodies == 10) {
            require(
                Groth16Verifier10(verifier).verifyProof(
                    a,
                    b,
                    c,
                    convertTo100(input)
                ),
                "Invalid 10 body proof"
            );
        } else {
            revert("Invalid number of bodies");
        }
        uint256[10] memory bodyIds = Problems(problems).getProblemBodyIds(
            problemId
        );

        Problems(problems).updateProblemTickCount(
            problemId,
            previousTickCount + tickCount
        );

        Tocks(tocks).mint(msg.sender, tickCount * bodyBoost[bodyCount]);

        // uint256 traits = 5;
        Problems.Body memory bodyData;
        for (uint256 i = 0; i < numberOfBodies; i++) {
            bodyData = Problems(problems).getProblemBodyData(
                problemId,
                bodyIds[i]
            );

            // px
            // confirm previously stored values were used as input to the proof
            // uint256 pxIndex = 5 * numberOfBodies + i * 5 + 0;
            // console.log("px");
            // console.log(bodyData.px);
            // console.log(input[5 * numberOfBodies + i * 5 + 0]);
            require(
                bodyData.px == input[5 * numberOfBodies + i * 5 + 0],
                "Invalid position x"
            );
            // update stored values
            bodyData.px = input[i * 5 + 0];

            // py
            // confirm previously stored values were used as input to the proof
            // uint256 pyIndex = 5 * numberOfBodies + i * 5 + 1;
            require(
                bodyData.py == input[5 * numberOfBodies + i * 5 + 1],
                "Invalid position y"
            );
            // update stored values
            bodyData.py = input[i * 5 + 1];

            // vx
            // confirm previously stored values were used as input to the proof
            // uint256 vxIndex = 5 * numberOfBodies + i * 5 + 2;
            // console.log("vx");
            // console.log(bodyData.vx);
            // console.log(input[5 * numberOfBodies + i * 5 + 2]);
            // console.log(input[i * 5 + 2]);
            require(
                bodyData.vx == input[5 * numberOfBodies + i * 5 + 2],
                "Invalid vector x"
            );
            // update stored values
            bodyData.vx = input[i * 5 + 2];

            // vy
            // confirm previously stored values were used as input to the proof
            // uint256 vyIndex = 5 * numberOfBodies + i * 5 + 3;
            // console.log("vy");
            // console.log("current:");
            // console.log(bodyData.vy);
            // console.log("submitted starting point:");
            // console.log(input[5 * numberOfBodies + i * 5 + 3]);
            // console.log("new value:");
            // console.log(input[i * 5 + 3]);
            require(
                bodyData.vy == input[5 * numberOfBodies + i * 5 + 3],
                "Invalid vector y"
            );
            // update stored values
            bodyData.vy = input[i * 5 + 3];

            // radius
            // confirm previously stored values were used as input to the proof
            // uint256 radiusIndex = 5 * numberOfBodies + i * 5 + 4;
            require(
                bodyData.radius == input[5 * numberOfBodies + i * 5 + 4],
                "Invalid radius"
            );
            // update stored values
            bodyData.radius = input[i * 5 + 4];
            Problems(problems).updateProblemBody(
                problemId,
                bodyIds[i],
                bodyData
            );
        }
        emit Solved(problemId, previousTickCount, tickCount);
    }

    function convertTo30(
        uint[] memory input
    ) internal pure returns (uint[30] memory) {
        uint[30] memory input_;
        for (uint256 i = 0; i < 30; i++) {
            input_[i] = input[i];
        }
        return input_;
    }

    function convertTo40(
        uint[] memory input
    ) internal pure returns (uint[40] memory) {
        uint[40] memory input_;
        for (uint256 i = 0; i < 40; i++) {
            input_[i] = input[i];
        }
        return input_;
    }

    function convertTo50(
        uint[] memory input
    ) internal pure returns (uint[50] memory) {
        uint[50] memory input_;
        for (uint256 i = 0; i < 50; i++) {
            input_[i] = input[i];
        }
        return input_;
    }

    function convertTo60(
        uint[] memory input
    ) internal pure returns (uint[60] memory) {
        uint[60] memory input_;
        for (uint256 i = 0; i < 60; i++) {
            input_[i] = input[i];
        }
        return input_;
    }

    function convertTo70(
        uint[] memory input
    ) internal pure returns (uint[70] memory) {
        uint[70] memory input_;
        for (uint256 i = 0; i < 70; i++) {
            input_[i] = input[i];
        }
        return input_;
    }

    function convertTo80(
        uint[] memory input
    ) internal pure returns (uint[80] memory) {
        uint[80] memory input_;
        for (uint256 i = 0; i < 80; i++) {
            input_[i] = input[i];
        }
        return input_;
    }

    function convertTo90(
        uint[] memory input
    ) internal pure returns (uint[90] memory) {
        uint[90] memory input_;
        for (uint256 i = 0; i < 90; i++) {
            input_[i] = input[i];
        }
        return input_;
    }

    function convertTo100(
        uint[] memory input
    ) internal pure returns (uint[100] memory) {
        uint[100] memory input_;
        for (uint256 i = 0; i < 100; i++) {
            input_[i] = input[i];
        }
        return input_;
    }

    // function convertToN(
    //     uint[] memory input,
    //     uint256 n
    // ) internal pure returns (uint[n] memory) {
    //     uint[n] memory input_;
    //     for (uint256 i = 0; i < n; i++) {
    //         input_[i] = input[i];
    //     }
    //     return input_;
    // }
}
